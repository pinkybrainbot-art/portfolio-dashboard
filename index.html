<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="robots" content="noindex, nofollow">
  <title>Portfolio Dashboard</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: #0d1117;
      color: #c9d1d9;
      min-height: 100vh;
    }
    
    /* Login Screen */
    .login-screen {
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 100vh;
      padding: 20px;
    }
    .login-box {
      background: #161b22;
      border: 1px solid #30363d;
      border-radius: 12px;
      padding: 40px;
      width: 100%;
      max-width: 360px;
      text-align: center;
    }
    .login-box h1 { color: #58a6ff; margin-bottom: 10px; font-size: 1.5rem; }
    .login-box p { color: #8b949e; margin-bottom: 25px; font-size: 0.9rem; }
    .pin-input {
      width: 100%;
      padding: 15px;
      background: #0d1117;
      border: 1px solid #30363d;
      border-radius: 8px;
      color: #c9d1d9;
      font-size: 1.5rem;
      text-align: center;
      letter-spacing: 8px;
      margin-bottom: 15px;
    }
    .pin-input:focus { outline: none; border-color: #58a6ff; }
    .login-error { color: #f85149; font-size: 0.85rem; margin-bottom: 15px; display: none; }
    .login-btn {
      width: 100%;
      padding: 12px;
      background: #238636;
      border: none;
      border-radius: 8px;
      color: white;
      font-size: 1rem;
      cursor: pointer;
    }
    .login-btn:hover { background: #2ea043; }
    .app-content { display: none; }
    
    /* Navigation */
    .nav {
      background: #161b22;
      border-bottom: 1px solid #30363d;
      padding: 15px 20px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      position: sticky;
      top: 0;
      z-index: 50;
      flex-wrap: wrap;
      gap: 10px;
    }
    .nav h1 { color: #58a6ff; font-size: 1.3rem; }
    .nav-tabs { display: flex; gap: 5px; flex-wrap: wrap; }
    .nav-tab {
      padding: 8px 16px;
      background: transparent;
      border: none;
      color: #8b949e;
      cursor: pointer;
      border-radius: 6px;
      font-size: 0.9rem;
    }
    .nav-tab:hover { color: #c9d1d9; background: #21262d; }
    .nav-tab.active { color: #58a6ff; background: #21262d; }
    
    .container { padding: 20px; max-width: 1400px; margin: 0 auto; }
    .tab-content { display: none; }
    .tab-content.active { display: block; }
    
    /* Cards */
    .card {
      background: #161b22;
      border: 1px solid #30363d;
      border-radius: 12px;
      padding: 20px;
      margin-bottom: 20px;
    }
    .card-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 15px;
    }
    .card-title { font-size: 1rem; color: #c9d1d9; }
    
    /* Grid Layouts */
    .grid-4 { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px; }
    .grid-2 { display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 20px; }
    .grid-3 { display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 15px; }
    
    /* Stat Cards */
    .stat-card {
      background: #161b22;
      border: 1px solid #30363d;
      border-radius: 12px;
      padding: 25px;
      text-align: center;
    }
    .stat-value { font-size: 1.8rem; font-weight: 700; color: #58a6ff; margin-bottom: 5px; }
    .stat-label { font-size: 0.85rem; color: #8b949e; }
    
    /* Tables */
    .table-container { overflow-x: auto; }
    table { width: 100%; border-collapse: collapse; }
    th, td { padding: 12px 15px; text-align: left; border-bottom: 1px solid #21262d; }
    th { color: #8b949e; font-weight: 500; font-size: 0.85rem; }
    td { font-size: 0.9rem; }
    tr:hover { background: #21262d; }
    .ticker { font-weight: 600; color: #58a6ff; }
    .positive { color: #3fb950; }
    .negative { color: #f85149; }
    
    /* Buttons */
    .btn {
      padding: 8px 16px;
      border: none;
      border-radius: 6px;
      cursor: pointer;
      font-size: 0.85rem;
      transition: all 0.2s;
    }
    .btn-primary { background: #238636; color: white; }
    .btn-primary:hover { background: #2ea043; }
    .btn-secondary { background: #21262d; color: #c9d1d9; border: 1px solid #30363d; }
    .btn-secondary:hover { background: #30363d; }
    .btn-ask {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      padding: 12px 24px;
      font-size: 1rem;
      display: flex;
      align-items: center;
      gap: 8px;
    }
    .btn-ask:hover { opacity: 0.9; transform: translateY(-1px); }
    .btn-ask:disabled { opacity: 0.6; cursor: not-allowed; transform: none; }
    
    /* Summary Bar */
    .summary-bar {
      display: flex;
      gap: 20px;
      padding: 15px 20px;
      background: #161b22;
      border-bottom: 1px solid #30363d;
      font-size: 0.85rem;
      flex-wrap: wrap;
    }
    .summary-item { display: flex; gap: 8px; align-items: center; }
    .summary-label { color: #8b949e; }
    .summary-value { font-weight: 600; }
    
    /* Holdings list */
    .holding-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 12px 0;
      border-bottom: 1px solid #21262d;
    }
    .holding-item:last-child { border-bottom: none; }
    .holding-ticker { font-weight: 600; color: #58a6ff; }
    .holding-name { font-size: 0.8rem; color: #8b949e; }
    .holding-value { text-align: right; }
    .holding-shares { font-size: 0.8rem; color: #8b949e; }
    
    /* Notes */
    .note-card {
      background: #21262d;
      border-radius: 8px;
      padding: 15px;
      margin-bottom: 10px;
    }
    .note-meta { font-size: 0.75rem; color: #8b949e; margin-bottom: 8px; display: flex; gap: 10px; }
    .note-author { color: #58a6ff; font-weight: 500; }
    .note-text { font-size: 0.9rem; line-height: 1.5; }
    .note-tags { margin-top: 10px; display: flex; gap: 5px; flex-wrap: wrap; }
    .tag { background: #30363d; padding: 2px 8px; border-radius: 12px; font-size: 0.75rem; color: #8b949e; }
    
    /* Macro indicators */
    .macro-card {
      background: #21262d;
      border-radius: 8px;
      padding: 15px;
      text-align: center;
    }
    .macro-value { font-size: 1.5rem; font-weight: 700; margin-bottom: 5px; }
    .macro-name { font-size: 0.85rem; color: #8b949e; }
    .macro-trend { font-size: 0.75rem; margin-top: 5px; }
    .trend-up { color: #3fb950; }
    .trend-down { color: #f85149; }
    .trend-neutral { color: #8b949e; }
    
    /* Watchlist */
    .watchlist-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 12px;
      background: #21262d;
      border-radius: 8px;
      margin-bottom: 10px;
    }
    .watchlist-ticker { font-weight: 600; color: #58a6ff; }
    .watchlist-note { font-size: 0.8rem; color: #8b949e; }
    
    /* Theses */
    .thesis-card {
      background: #21262d;
      border-radius: 8px;
      padding: 15px;
    }
    .thesis-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px; }
    .thesis-ticker { font-weight: 600; color: #58a6ff; font-size: 1.1rem; }
    .thesis-conviction {
      padding: 3px 10px;
      border-radius: 12px;
      font-size: 0.75rem;
      text-transform: uppercase;
    }
    .conviction-high { background: #238636; color: white; }
    .conviction-medium { background: #9e6a03; color: white; }
    .conviction-low { background: #6e7681; color: white; }
    .thesis-text { font-size: 0.9rem; line-height: 1.5; color: #c9d1d9; }
    
    /* Ask Pinky Section */
    .ask-pinky-section {
      background: linear-gradient(135deg, #1a1f35 0%, #161b22 100%);
      border: 1px solid #30363d;
      border-radius: 12px;
      padding: 25px;
      text-align: center;
      margin-bottom: 20px;
    }
    .ask-pinky-title { font-size: 1.2rem; margin-bottom: 10px; display: flex; align-items: center; justify-content: center; gap: 10px; }
    .ask-pinky-desc { color: #8b949e; font-size: 0.9rem; margin-bottom: 20px; }
    .ask-response {
      background: #0d1117;
      border-radius: 8px;
      padding: 20px;
      margin-top: 20px;
      text-align: left;
      display: none;
    }
    .ask-response.active { display: block; }
    .ask-response-text { white-space: pre-wrap; line-height: 1.6; }
    .analysis-content { line-height: 1.7; }
    .analysis-content h4 { color: #58a6ff; margin: 20px 0 10px 0; font-size: 0.95rem; font-weight: 600; border-bottom: 1px solid #30363d; padding-bottom: 5px; }
    .analysis-content h4:first-child { margin-top: 5px; }
    .analysis-content p { margin: 8px 0; color: #c9d1d9; }
    .analysis-content ul { margin: 10px 0; padding-left: 0; list-style: none; }
    .analysis-content li { margin: 8px 0; padding-left: 20px; position: relative; color: #c9d1d9; }
    .analysis-content li:before { content: "‚Ä¢"; position: absolute; left: 5px; color: #58a6ff; }
    .analysis-content strong { color: #f0f6fc; }
    
    /* Modals */
    .modal-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0,0,0,0.7);
      display: none;
      justify-content: center;
      align-items: center;
      z-index: 100;
      padding: 20px;
    }
    .modal-overlay.active { display: flex; }
    .modal {
      background: #161b22;
      border: 1px solid #30363d;
      border-radius: 12px;
      padding: 25px;
      width: 100%;
      max-width: 500px;
      max-height: 90vh;
      overflow-y: auto;
    }
    .modal h2 { margin-bottom: 20px; font-size: 1.2rem; }
    .form-group { margin-bottom: 15px; }
    .form-group label { display: block; margin-bottom: 5px; font-size: 0.85rem; color: #8b949e; }
    .form-group input, .form-group textarea, .form-group select {
      width: 100%;
      padding: 10px;
      background: #0d1117;
      border: 1px solid #30363d;
      border-radius: 6px;
      color: #c9d1d9;
      font-size: 0.9rem;
    }
    .form-group input:focus, .form-group textarea:focus, .form-group select:focus {
      outline: none;
      border-color: #58a6ff;
    }
    .modal-actions { display: flex; gap: 10px; justify-content: flex-end; margin-top: 20px; }
    
    /* Config notice */
    .config-notice {
      background: #9e6a03;
      color: white;
      padding: 15px 20px;
      text-align: center;
      font-size: 0.9rem;
    }
    .config-notice a { color: white; }
    
    /* Loading */
    .loading { text-align: center; padding: 40px; color: #8b949e; }
    .spinner {
      border: 3px solid #30363d;
      border-top: 3px solid #58a6ff;
      border-radius: 50%;
      width: 30px;
      height: 30px;
      animation: spin 1s linear infinite;
      margin: 0 auto 15px;
    }
    @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
    
    /* Responsive */
    @media (max-width: 768px) {
      .nav { flex-direction: column; align-items: flex-start; }
      .stat-value { font-size: 1.4rem; }
      .grid-4 { grid-template-columns: repeat(2, 1fr); }
    }
  </style>
</head>
<body>
  <!-- Config Notice (shown when Supabase not configured) -->
  <div class="config-notice" id="configNotice" style="display:none;">
    ‚ö†Ô∏è Supabase not configured. Using local data. <a href="#" onclick="showConfigModal()">Configure now</a>
  </div>

  <!-- Login Screen -->
  <div class="login-screen" id="loginScreen">
    <div class="login-box">
      <h1>üîê Portfolio Dashboard</h1>
      <p>Enter your PIN to access</p>
      <input type="password" class="pin-input" id="pinInput" placeholder="‚Ä¢‚Ä¢‚Ä¢‚Ä¢" maxlength="6" autofocus>
      <div class="login-error" id="loginError">Incorrect PIN</div>
      <button class="login-btn" onclick="checkPin()">Unlock</button>
    </div>
  </div>
  
  <!-- App Content -->
  <div class="app-content" id="appContent">
    <nav class="nav">
      <h1>üìä Portfolio Dashboard</h1>
      <div class="nav-tabs">
        <button class="nav-tab active" data-tab="overview">Overview</button>
        <button class="nav-tab" data-tab="holdings">Holdings</button>
        <button class="nav-tab" data-tab="theses">Frameworks</button>
        <button class="nav-tab" data-tab="transactions">Log</button>
        <button class="nav-tab" data-tab="watchlist">Watchlist</button>
        <button class="nav-tab" data-tab="earnings">Earnings</button>
        <button class="nav-tab" data-tab="notes">Notes</button>
      </div>
    </nav>
    
    <div class="summary-bar">
      <div class="summary-item">
        <span class="summary-label">Total Value:</span>
        <span class="summary-value" id="totalValue">$0</span>
      </div>
      <div class="summary-item">
        <span class="summary-label">Positions:</span>
        <span class="summary-value" id="positionCount">0</span>
      </div>
      <div class="summary-item">
        <span class="summary-label">Last Updated:</span>
        <span class="summary-value" id="lastUpdated">-</span>
      </div>
    </div>
    
    <div class="container">
      <!-- Overview Tab -->
      <div class="tab-content active" id="overview">
        <div class="grid-4" style="margin-bottom: 20px;">
          <div class="stat-card">
            <div class="stat-value" id="statStocks">$0</div>
            <div class="stat-label">Stocks</div>
          </div>
          <div class="stat-card">
            <div class="stat-value" id="statCrypto">$0</div>
            <div class="stat-label">Crypto</div>
          </div>
          <div class="stat-card">
            <div class="stat-value" id="statYTD">-</div>
            <div class="stat-label">YTD Return</div>
          </div>
        </div>
        
        <div class="card">
          <div class="card-header">
            <span class="card-title">üìà Year to Date Performance</span>
            <div style="display: flex; align-items: center; gap: 10px;">
              <span id="priceStatus" style="font-size: 0.75rem; color: #8b949e;"></span>
              <button class="btn btn-primary" onclick="refreshPrices()" style="padding: 6px 12px; font-size: 0.8rem;">üîÑ Refresh</button>
            </div>
          </div>
          <canvas id="valueChart" height="100"></canvas>
        </div>
        
        <div class="grid-2">
          <div class="card">
            <div class="card-header">
              <span class="card-title">üíº Top Holdings</span>
            </div>
            <div id="topHoldings"></div>
          </div>
          
          <div class="card">
            <div class="card-header">
              <span class="card-title">üß† Pinky's Thoughts</span>
              <div style="display: flex; align-items: center; gap: 10px;">
                <select id="aiModelSelect" style="padding: 8px 12px; background: #21262d; border: 1px solid #30363d; border-radius: 6px; color: #c9d1d9; font-size: 0.85rem;">
                  <option value="anthropic">Claude (Anthropic)</option>
                  <option value="openai">GPT-4o (OpenAI)</option>
                </select>
                <button class="btn btn-ask" onclick="askPinky('quick')" id="askQuickBtn">
                  üîÆ Quick Analysis
                </button>
              </div>
            </div>
            <div id="pinkyAnalysis">
              <div class="note-card" id="latestAnalysisCard" style="display: none;">
                <div class="note-meta">
                  <span id="analysisTimestamp"></span>
                </div>
                <div class="analysis-content" id="latestAnalysisText"></div>
              </div>
              <p id="noAnalysisMsg" style="color:#8b949e;">No recent analysis. Click "Quick Analysis" for insights on your top 5 holdings.</p>
            </div>
          </div>
        </div>
      </div>
      
      <!-- Holdings Tab -->
      <div class="tab-content" id="holdings">
        <div class="card">
          <div class="card-header">
            <span class="card-title">üìà Stocks</span>
            <button class="btn btn-primary" onclick="openModal('holdingModal')">+ Add</button>
          </div>
          <div class="table-container">
            <table>
              <thead>
                <tr>
                  <th>Symbol</th>
                  <th>Name</th>
                  <th>Shares</th>
                  <th>Price</th>
                  <th>Value</th>
                  <th>%</th>
                  <th></th>
                </tr>
              </thead>
              <tbody id="stocksTable"></tbody>
            </table>
          </div>
        </div>
        
        <div class="card">
          <div class="card-header">
            <span class="card-title">ü™ô Crypto</span>
          </div>
          <div class="table-container">
            <table>
              <thead>
                <tr>
                  <th>Symbol</th>
                  <th>Name</th>
                  <th>Shares</th>
                  <th>Price</th>
                  <th>Value</th>
                  <th>%</th>
                  <th></th>
                </tr>
              </thead>
              <tbody id="cryptoTable"></tbody>
            </table>
          </div>
        </div>
        
        <!-- AI Analysis Boxes -->
        <div class="grid-2" style="margin-top: 20px;">
          <div class="card">
            <div class="card-header">
              <span class="card-title">üöÄ High Risk/Reward Plays</span>
              <button class="btn btn-ask" onclick="getAIRecommendations('highRisk')" id="highRiskBtn">
                üé≤ Get Ideas
              </button>
            </div>
            <div id="highRiskAnalysis">
              <div class="note-card" id="highRiskCard" style="display: none;">
                <div class="note-meta">
                  <span id="highRiskTimestamp"></span>
                </div>
                <div class="analysis-content" id="highRiskText"></div>
              </div>
              <p id="noHighRiskMsg" style="color:#8b949e;">Click "Get Ideas" for short-term high risk/reward stock recommendations.</p>
            </div>
          </div>
          
          <div class="card">
            <div class="card-header">
              <span class="card-title">‚öñÔ∏è Portfolio Rebalance</span>
              <button class="btn btn-ask" onclick="getAIRecommendations('rebalance')" id="rebalanceBtn">
                üîÑ Analyze
              </button>
            </div>
            <div id="rebalanceAnalysis">
              <div class="note-card" id="rebalanceCard" style="display: none;">
                <div class="note-meta">
                  <span id="rebalanceTimestamp"></span>
                </div>
                <div class="analysis-content" id="rebalanceText"></div>
              </div>
              <p id="noRebalanceMsg" style="color:#8b949e;">Click "Analyze" for AI recommendations on what to sell and where to add exposure.</p>
            </div>
          </div>
        </div>
      </div>
      
      <!-- Investment Frameworks Tab -->
      <div class="tab-content" id="theses">
        <!-- AI Framework Analysis -->
        <div class="card" style="margin-bottom: 20px;">
          <div class="card-header">
            <span class="card-title">üß≠ AI Investment Framework</span>
            <button class="btn btn-ask" onclick="runFrameworkAnalysis()" id="frameworkBtn">
              üöÄ Run Framework
            </button>
          </div>
          <div id="frameworkAnalysis">
            <div class="note-card" id="frameworkCard" style="display: none;">
              <div class="note-meta">
                <span id="frameworkTimestamp"></span>
              </div>
              <div class="analysis-content" id="frameworkText"></div>
            </div>
            <p id="noFrameworkMsg" style="color:#8b949e;">Click "Run Framework" for a comprehensive AI-generated investment framework covering 1, 3, and 5 year horizons with macro regimes, investment buckets, and allocation strategies.</p>
          </div>
        </div>
        
        <!-- High Conviction Plays -->
        <div class="card" style="margin-bottom: 20px;">
          <div class="card-header">
            <span class="card-title">üéØ High Conviction Plays</span>
            <button class="btn btn-ask" onclick="runConvictionAnalysis()" id="convictionBtn">
              üî• Generate Picks
            </button>
          </div>
          <div id="convictionAnalysis">
            <div class="note-card" id="convictionCard" style="display: none;">
              <div class="note-meta">
                <span id="convictionTimestamp"></span>
              </div>
              <div class="analysis-content" id="convictionText"></div>
            </div>
            <p id="noConvictionMsg" style="color:#8b949e;">Click "Generate Picks" for AI-ranked highest conviction stocks for 1yr, 3yr, and 5yr returns based on the Investment Framework above.</p>
          </div>
        </div>
        
      </div>
      
      <!-- Transactions Tab -->
      <div class="tab-content" id="transactions">
        <div class="card">
          <div class="card-header">
            <span class="card-title">üìú Transaction Log</span>
            <button class="btn btn-primary" onclick="editingTransactionIdx=null;clearForm('transaction');openModal('transactionModal')">+ Add</button>
          </div>
          <div id="transactionLog"></div>
        </div>
      </div>
      
      <!-- Watchlist Tab -->
      <div class="tab-content" id="watchlist">
        <div class="card">
          <div class="card-header">
            <span class="card-title">üëÄ Watchlist</span>
            <button class="btn btn-primary" onclick="openModal('watchlistModal')">+ Add</button>
          </div>
          <div id="watchlistItems"></div>
        </div>
        
        <!-- AI Watchlist Analysis -->
        <div class="card" style="margin-top: 20px;">
          <div class="card-header">
            <span class="card-title">üéØ Should You Buy Today?</span>
            <button class="btn btn-ask" onclick="analyzeWatchlist()" id="watchlistAnalysisBtn">
              üîç Analyze Watchlist
            </button>
          </div>
          <div id="watchlistAnalysis">
            <div class="note-card" id="watchlistAnalysisCard" style="display: none;">
              <div class="note-meta">
                <span id="watchlistAnalysisTimestamp"></span>
              </div>
              <div class="analysis-content" id="watchlistAnalysisText"></div>
            </div>
            <p id="noWatchlistAnalysisMsg" style="color:#8b949e;">Click "Analyze Watchlist" to see if any watchlist stocks warrant investment today based on your current portfolio.</p>
          </div>
        </div>
      </div>
      
      <!-- Earnings Tab -->
      <div class="tab-content" id="earnings">
        <div class="card">
          <div class="card-header">
            <span class="card-title">üìÖ Upcoming Earnings</span>
            <button class="btn btn-primary" onclick="fetchEarningsDates()" id="refreshEarningsBtn">üîÑ Refresh Dates</button>
          </div>
          <p style="color:#8b949e; margin-bottom: 15px; font-size: 0.85rem;">Earnings dates for your holdings. Dates are estimates and may change.</p>
          <div class="table-container">
            <table>
              <thead>
                <tr>
                  <th>Date</th>
                  <th>Symbol</th>
                  <th>Company</th>
                  <th>Days Away</th>
                  <th>Status</th>
                  <th></th>
                </tr>
              </thead>
              <tbody id="earningsTable"></tbody>
            </table>
          </div>
        </div>
        
        <div class="card" style="margin-top: 20px;">
          <div class="card-header">
            <span class="card-title">üìä Earnings This Week</span>
          </div>
          <div id="earningsThisWeek"></div>
        </div>
      </div>
      
      <!-- Notes Tab -->
      <div class="tab-content" id="notes">
        <div class="card">
          <div class="card-header">
            <span class="card-title">üìù Notes</span>
            <button class="btn btn-primary" onclick="openModal('noteModal')">+ Add</button>
          </div>
          <div id="notesList"></div>
        </div>
      </div>
    </div>
  </div>
  
  <!-- Modals -->
  <div class="modal-overlay" id="holdingModal">
    <div class="modal">
      <h2>Add/Edit Holding</h2>
      <div class="form-group">
        <label>Symbol</label>
        <input type="text" id="holdingSymbol" placeholder="TSLA">
      </div>
      <div class="form-group">
        <label>Name</label>
        <input type="text" id="holdingName" placeholder="Tesla Inc">
      </div>
      <div class="form-group">
        <label>Shares</label>
        <input type="number" step="0.00000001" id="holdingShares" placeholder="100">
      </div>
      <div class="form-group">
        <label>Current Price</label>
        <input type="number" step="0.01" id="holdingPrice" placeholder="250.00">
      </div>
      <div class="form-group">
        <label>Type</label>
        <select id="holdingType">
          <option value="stock">Stock</option>
          <option value="crypto">Crypto</option>
        </select>
      </div>
      <div class="modal-actions">
        <button class="btn btn-secondary" onclick="closeModal('holdingModal')">Cancel</button>
        <button class="btn btn-primary" onclick="saveHolding()">Save</button>
      </div>
    </div>
  </div>
  
  <div class="modal-overlay" id="noteModal">
    <div class="modal">
      <h2>Add Note</h2>
      <div class="form-group">
        <label>Author</label>
        <select id="noteAuthor">
          <option value="chris">Chris</option>
          <option value="pinky">Pinky</option>
        </select>
      </div>
      <div class="form-group">
        <label>Note</label>
        <textarea id="noteText" rows="4" placeholder="Your thoughts..."></textarea>
      </div>
      <div class="form-group">
        <label>Tags (comma separated)</label>
        <input type="text" id="noteTags" placeholder="strategy, crypto">
      </div>
      <div class="modal-actions">
        <button class="btn btn-secondary" onclick="closeModal('noteModal')">Cancel</button>
        <button class="btn btn-primary" onclick="saveNote()">Save</button>
      </div>
    </div>
  </div>
  
  <div class="modal-overlay" id="transactionModal">
    <div class="modal">
      <h2>Add Transaction</h2>
      <div class="form-group">
        <label>Symbol</label>
        <input type="text" id="txSymbol" placeholder="TSLA">
      </div>
      <div class="form-group">
        <label>Action</label>
        <select id="txAction">
          <option value="buy">Buy</option>
          <option value="sell">Sell</option>
        </select>
      </div>
      <div class="form-group">
        <label>Shares</label>
        <input type="number" step="0.00000001" id="txShares" placeholder="10">
      </div>
      <div class="form-group">
        <label>Price</label>
        <input type="number" step="0.01" id="txPrice" placeholder="250.00">
      </div>
      <div class="form-group">
        <label>Date</label>
        <input type="date" id="txDate">
      </div>
      <div class="modal-actions">
        <button class="btn btn-secondary" onclick="closeModal('transactionModal')">Cancel</button>
        <button class="btn btn-primary" onclick="saveTransaction()">Save</button>
      </div>
    </div>
  </div>
  
  <div class="modal-overlay" id="watchlistModal">
    <div class="modal">
      <h2>Add to Watchlist</h2>
      <div class="form-group">
        <label>Symbol</label>
        <input type="text" id="watchSymbol" placeholder="AAPL">
      </div>
      <div class="form-group">
        <label>Notes</label>
        <textarea id="watchNotes" rows="3" placeholder="Why watching..."></textarea>
      </div>
      <div class="form-group">
        <label>Target Entry Price</label>
        <input type="number" step="0.01" id="watchTarget" placeholder="150.00">
      </div>
      <div class="modal-actions">
        <button class="btn btn-secondary" onclick="closeModal('watchlistModal')">Cancel</button>
        <button class="btn btn-primary" onclick="saveWatchlist()">Save</button>
      </div>
    </div>
  </div>
  
  <div class="modal-overlay" id="thesisModal">
    <div class="modal">
      <h2>Add Investment Thesis</h2>
      <div class="form-group">
        <label>Symbol</label>
        <input type="text" id="thesisSymbol" placeholder="TSLA">
      </div>
      <div class="form-group">
        <label>Thesis</label>
        <textarea id="thesisText" rows="4" placeholder="Your investment thesis..."></textarea>
      </div>
      <div class="form-group">
        <label>Conviction</label>
        <select id="thesisConviction">
          <option value="high">High</option>
          <option value="medium">Medium</option>
          <option value="low">Low</option>
        </select>
      </div>
      <div class="form-group">
        <label>Target Price</label>
        <input type="number" step="0.01" id="thesisTarget" placeholder="500.00">
      </div>
      <div class="modal-actions">
        <button class="btn btn-secondary" onclick="closeModal('thesisModal')">Cancel</button>
        <button class="btn btn-primary" onclick="saveThesis()">Save</button>
      </div>
    </div>
  </div>
  
  <div class="modal-overlay" id="configModal">
    <div class="modal">
      <h2>‚öôÔ∏è Supabase Configuration</h2>
      <p style="color: #8b949e; margin-bottom: 20px; font-size: 0.9rem;">
        Connect to Supabase for persistent storage. Get your credentials from your Supabase project settings.
      </p>
      <div class="form-group">
        <label>Supabase URL</label>
        <input type="text" id="configUrl" placeholder="https://xxxxx.supabase.co">
      </div>
      <div class="form-group">
        <label>Anon Key</label>
        <input type="text" id="configKey" placeholder="eyJhbGci...">
      </div>
      <div class="modal-actions">
        <button class="btn btn-secondary" onclick="closeModal('configModal')">Cancel</button>
        <button class="btn btn-primary" onclick="saveConfig()">Connect</button>
      </div>
    </div>
  </div>

  <script>
    // ==================== CONFIG ====================
    const PIN_HASH = '4dea5c7cb70f50322ec9d734aa4aa078be9227c05251e18991c596f387552370'; // SHA256 of '1984'
    const SESSION_KEY = 'portfolio-auth-v2';
    const TELEGRAM_BOT_USERNAME = 'PinkyPablo_bot';
    
    // Supabase config (pre-configured, can override via localStorage)
    let supabaseUrl = localStorage.getItem('supabase_url') || 'https://wfifrubydsyyrspneqst.supabase.co';
    let supabaseKey = localStorage.getItem('supabase_key') || 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6IndmaWZydWJ5ZHN5eXJzcG5lcXN0Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NzAwNTUxNTQsImV4cCI6MjA4NTYzMTE1NH0.SbniMd6HizrdeZIRT77iguGDoJeo2MThEEXcXDm13UY';
    let supabaseClient = null;
    
    // ==================== DEFAULT DATA ====================
    const DEFAULT_DATA = {
      holdings: [
        { symbol: 'TSLA', name: 'Tesla', shares: 215.31, price: 421.81, type: 'stock' },
        { symbol: 'CARR', name: 'Carrier Global', shares: 193.24, price: 60.36, type: 'stock' },
        { symbol: 'ANET', name: 'Arista Networks', shares: 77.07, price: 138.37, type: 'stock' },
        { symbol: 'NVDA', name: 'NVIDIA', shares: 38.57, price: 185.61, type: 'stock' },
        { symbol: 'FTNT', name: 'Fortinet', shares: 84.44, price: 81.29, type: 'stock' },
        { symbol: 'MRVL', name: 'Marvell Technology', shares: 83.81, price: 78.66, type: 'stock' },
        { symbol: 'SNOW', name: 'Snowflake', shares: 48.14, price: 190.68, type: 'stock' },
        { symbol: 'HIMS', name: 'Hims & Hers Health', shares: 545.40, price: 26.44, type: 'stock' },
        { symbol: 'MSTR', name: 'MicroStrategy', shares: 153.45, price: 139.63, type: 'stock' },
        { symbol: 'BTC', name: 'Bitcoin', shares: 1, price: 78069, type: 'crypto' },
        { symbol: 'SOL', name: 'Solana', shares: 121, price: 103.01, type: 'crypto' },
      ],
      cash: 32460,
      weeklyValues: [
        { date: '2026-01-06', value: 285000 },
        { date: '2026-01-13', value: 295000 },
        { date: '2026-01-20', value: 310000 },
        { date: '2026-01-27', value: 320000 },
        { date: '2026-02-02', value: 301783 },
      ],
      theses: [
        { symbol: 'TSLA', thesis: 'Robotaxi and humanoid robots not priced in. Full autonomy could 10x revenue. Optimus humanoid is massive TAM.', conviction: 'high', target: 1000 },
        { symbol: 'NVDA', thesis: 'AI infrastructure backbone. Every major company needs their chips. Moat is deep.', conviction: 'high', target: 200 },
        { symbol: 'HIMS', thesis: 'DTC healthcare disruption. Growing revenue 50%+ YoY. GLP-1s are huge catalyst.', conviction: 'medium', target: 80 },
      ],
      watchlist: [
        { symbol: 'CRWV', notes: 'AI infrastructure play. High risk/reward. Watch for entry.', target: 35 },
        { symbol: 'RKLB', notes: 'Space optionality. Rocket Lab has real customers.', target: 20 },
        { symbol: 'MU', notes: 'Best value in semis. Memory cycle turning.', target: 90 },
      ],
      transactions: [
        { symbol: 'TSLA', action: 'buy', shares: 30, price: 418, date: '2026-02-02', notes: 'Good entry on dip' },
        { symbol: 'SUI', action: 'sell', shares: 2500, price: 4.20, date: '2026-01-30', notes: 'Taking profits, crypto bearish' },
        { symbol: 'IONQ', action: 'sell', shares: 150, price: 42.50, date: '2026-01-28', notes: 'Quantum hype overblown' },
        { symbol: 'LMT', action: 'sell', shares: 45, price: 485.00, date: '2026-01-25', notes: 'Taking profits' },
      ],
      notes: [
        { date: '2026-02-02', author: 'pinky', text: 'Portfolio repositioning complete. Sold speculative positions and holding $45k cash for high-conviction entries.', tags: ['strategy'] },
        { date: '2026-02-02', author: 'pinky', text: 'Crypto in bear mode ‚Äî BTC dominance rising. Keeping core BTC + SOL positions. Patience over FOMO.', tags: ['crypto', 'macro'] },
        { date: '2026-02-01', author: 'chris', text: 'Want long term holds that can realistically 3X. Looking for undervalued plays.', tags: ['strategy'] },
      ],
      liquidityIndicators: [
        { id: 'global-m2', name: 'Global M2 YoY', value: '+3.8%', trend: 'up' },
        { id: 'us-m2', name: 'US M2 YoY', value: '+3.2%', trend: 'up' },
        { id: 'fed-bs', name: 'Fed Balance Sheet', value: '$6.81T', trend: 'down' },
        { id: 'fed-net-liq', name: 'Fed Net Liquidity', value: '$5.92T', trend: 'neutral' },
        { id: 'tga', name: 'Treasury TGA', value: '$722B', trend: 'up' },
        { id: 'rrp', name: 'Reverse Repo', value: '$168B', trend: 'down' },
        { id: 'cb-combined', name: 'G4 Central Banks', value: '$28.1T', trend: 'neutral' },
        { id: 'm2-spx-lag', name: 'M2‚ÜíSPX Signal', value: 'Bullish', trend: 'up' },
      ],
      ratesIndicators: [
        { id: '10y', name: '10Y Treasury', value: '4.52%', trend: 'up' },
        { id: '2y', name: '2Y Treasury', value: '4.21%', trend: 'up' },
        { id: 'real-rate', name: 'Real Rate (10Y-BEI)', value: '2.12%', trend: 'up' },
        { id: 'yield-curve', name: '2Y/10Y Spread', value: '+31bp', trend: 'up' },
        { id: 'fed-funds', name: 'Fed Funds Rate', value: '4.50%', trend: 'neutral' },
        { id: 'fed-terminal', name: 'Terminal Rate Exp', value: '3.75%', trend: 'down' },
        { id: 'cuts-2026', name: 'Cuts Priced 2026', value: '2-3 cuts', trend: 'neutral' },
        { id: 'bei', name: 'Breakeven Inflation', value: '2.40%', trend: 'neutral' },
      ],
      creditIndicators: [
        { id: 'hy-spread', name: 'HY Spread (OAS)', value: '289bp', trend: 'neutral' },
        { id: 'ig-spread', name: 'IG Spread (OAS)', value: '87bp', trend: 'neutral' },
        { id: 'hy-vs-avg', name: 'HY vs 10Y Avg', value: 'Below', trend: 'up' },
        { id: 'cdx-hy', name: 'CDX HY Index', value: '342', trend: 'neutral' },
        { id: 'cdx-ig', name: 'CDX IG Index', value: '52', trend: 'neutral' },
        { id: 'loan-delinq', name: 'Loan Delinquency', value: '1.54%', trend: 'up' },
        { id: 'credit-cond', name: 'Credit Conditions', value: 'Tight', trend: 'down' },
        { id: 'hyg-lqd', name: 'HYG/LQD Ratio', value: '0.72', trend: 'neutral' },
      ],
      inflationIndicators: [
        { id: 'cpi-yoy', name: 'CPI YoY', value: '2.9%', trend: 'down' },
        { id: 'cpi-mom', name: 'CPI MoM', value: '0.4%', trend: 'up' },
        { id: 'core-cpi', name: 'Core CPI YoY', value: '3.2%', trend: 'down' },
        { id: 'pce-yoy', name: 'PCE YoY', value: '2.6%', trend: 'down' },
        { id: 'core-pce', name: 'Core PCE YoY', value: '2.8%', trend: 'down' },
        { id: '5y5y', name: '5Y5Y Breakeven', value: '2.35%', trend: 'neutral' },
        { id: 'oil', name: 'Oil (WTI)', value: '$73', trend: 'down' },
        { id: 'commodities', name: 'CRB Index', value: '275', trend: 'neutral' },
      ],
      growthIndicators: [
        { id: 'ism-mfg', name: 'ISM Manufacturing', value: '49.3', trend: 'up' },
        { id: 'ism-svc', name: 'ISM Services', value: '54.1', trend: 'up' },
        { id: 'new-orders', name: 'New Orders', value: '52.5', trend: 'up' },
        { id: 'orders-inv', name: 'Orders vs Inventory', value: '+3.2', trend: 'up' },
        { id: 'pmi-comp', name: 'PMI Composite', value: '52.4', trend: 'up' },
        { id: 'retail-real', name: 'Real Retail Sales', value: '+0.4%', trend: 'up' },
        { id: 'ind-prod', name: 'Industrial Prod MoM', value: '+0.9%', trend: 'up' },
        { id: 'gdp-now', name: 'GDPNow Estimate', value: '2.9%', trend: 'up' },
      ],
      labourIndicators: [
        { id: 'init-claims', name: 'Initial Claims', value: '219K', trend: 'neutral' },
        { id: 'init-4wk', name: 'Claims 4-Wk Avg', value: '215K', trend: 'neutral' },
        { id: 'cont-claims', name: 'Continuing Claims', value: '1.89M', trend: 'up' },
        { id: 'unemp', name: 'Unemployment Rate', value: '4.1%', trend: 'neutral' },
        { id: 'sahm', name: 'Sahm Rule', value: '0.43', trend: 'neutral' },
        { id: 'sahm-status', name: 'Sahm Triggered?', value: 'No', trend: 'up' },
        { id: 'wage-growth', name: 'Wage Growth YoY', value: '4.1%', trend: 'down' },
        { id: 'wage-prod', name: 'Wages vs Productivity', value: '+1.2%', trend: 'neutral' },
      ],
      earningsIndicators: [
        { id: 'fwd-eps', name: 'S&P Fwd EPS', value: '$275', trend: 'up' },
        { id: 'fwd-pe', name: 'Forward P/E', value: '21.9x', trend: 'neutral' },
        { id: 'eps-revisions', name: 'EPS Revisions', value: '+1.2', trend: 'up' },
        { id: 'rev-ratio', name: 'Up/Down Ratio', value: '1.8x', trend: 'up' },
        { id: 'margins', name: 'S&P Net Margins', value: '12.1%', trend: 'neutral' },
        { id: 'margins-hist', name: 'Margins vs Avg', value: 'Above', trend: 'up' },
        { id: 'cape', name: 'CAPE Ratio', value: '36.2', trend: 'neutral' },
        { id: 'cape-context', name: 'CAPE vs History', value: 'Top 5%', trend: 'down' },
      ],
      internalsIndicators: [
        { id: 'ad-line', name: 'A/D Line Trend', value: 'Rising', trend: 'up' },
        { id: 'ad-diverge', name: 'A/D vs SPX', value: 'Confirming', trend: 'up' },
        { id: 'above-200', name: '% Above 200-DMA', value: '58%', trend: 'neutral' },
        { id: 'above-50', name: '% Above 50-DMA', value: '52%', trend: 'neutral' },
        { id: 'rsp-spy', name: 'RSP/SPY Ratio', value: '0.31', trend: 'down' },
        { id: 'breadth', name: 'Breadth Thrust', value: 'Neutral', trend: 'neutral' },
        { id: 'new-hi-lo', name: 'New Highs - Lows', value: '+42', trend: 'up' },
        { id: 'sector-breadth', name: 'Sectors Bullish', value: '7/11', trend: 'up' },
      ],
      volIndicators: [
        { id: 'vix', name: 'VIX', value: '18.2', trend: 'neutral' },
        { id: 'vix-term', name: 'VIX Term Structure', value: 'Contango', trend: 'up' },
        { id: 'vix9d', name: 'VIX9D vs VIX', value: 'Below', trend: 'up' },
        { id: 'vvix', name: 'VVIX (Vol of Vol)', value: '92', trend: 'neutral' },
        { id: 'put-call', name: 'Put/Call Ratio', value: '0.82', trend: 'neutral' },
        { id: 'skew', name: 'SKEW Index', value: '142', trend: 'neutral' },
        { id: 'gex', name: 'Dealer GEX', value: '+$2.1B', trend: 'up' },
        { id: 'dix', name: 'DIX (Dark Pool)', value: '44.2%', trend: 'neutral' },
      ],
      globalIndicators: [
        { id: 'dxy', name: 'DXY (USD Index)', value: '108.4', trend: 'up' },
        { id: 'dxy-trend', name: 'DXY Trend', value: 'Strong', trend: 'down' },
        { id: 'em-fx', name: 'EM FX Basket', value: 'Weak', trend: 'down' },
        { id: 'usd-cny', name: 'USD/CNY', value: '7.29', trend: 'up' },
        { id: 'china-credit', name: 'China Credit Impulse', value: '+2.1%', trend: 'up' },
        { id: 'china-pmi', name: 'China PMI', value: '50.1', trend: 'neutral' },
        { id: 'baltic-dry', name: 'Baltic Dry Index', value: '1,024', trend: 'down' },
        { id: 'world-trade', name: 'World Trade Vol', value: '+1.8%', trend: 'neutral' },
      ],
      sentimentIndicators: [
        { id: 'aaii-bull', name: 'AAII Bulls', value: '34.2%', trend: 'neutral' },
        { id: 'aaii-bear', name: 'AAII Bears', value: '38.1%', trend: 'neutral' },
        { id: 'aaii-spread', name: 'Bull-Bear Spread', value: '-3.9%', trend: 'up' },
        { id: 'naaim', name: 'NAAIM Exposure', value: '72.4', trend: 'neutral' },
        { id: 'fear-greed', name: 'Fear & Greed', value: '44', trend: 'neutral' },
        { id: 'fund-flows', name: 'Equity Fund Flows', value: '+$8.2B', trend: 'up' },
        { id: 'margin-debt', name: 'Margin Debt', value: '$780B', trend: 'neutral' },
        { id: 'margin-chg', name: 'Margin Debt MoM', value: '+1.2%', trend: 'neutral' },
      ],
      macroIndicators: [
        { id: 'vix', name: 'VIX', value: '18.2', trend: 'up' },
        { id: 'dxy', name: 'DXY', value: '108.4', trend: 'up' },
        { id: 'btc-dom', name: 'BTC Dominance', value: '58.2%', trend: 'up' },
        { id: '10y', name: '10Y Treasury', value: '4.52%', trend: 'up' },
        { id: 'fear-greed', name: 'Fear & Greed', value: '44', trend: 'down' },
        { id: 'spx', name: 'S&P 500', value: '6,040', trend: 'neutral' },
        { id: 'btc-liq', name: 'BTC Liq Levels', value: '$92k/$104k', trend: 'neutral' },
        { id: 'hy-spread', name: 'HY Spreads', value: '2.89%', trend: 'neutral' },
      ],
      lastUpdated: new Date().toISOString()
    };
    
    let data = JSON.parse(JSON.stringify(DEFAULT_DATA));
    
    // ==================== AUTH ====================
    async function sha256(message) {
      const msgBuffer = new TextEncoder().encode(message);
      const hashBuffer = await crypto.subtle.digest('SHA-256', msgBuffer);
      const hashArray = Array.from(new Uint8Array(hashBuffer));
      return hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
    }
    
    async function checkPin() {
      const pin = document.getElementById('pinInput').value;
      const hash = await sha256(pin);
      if (hash === PIN_HASH) {
        sessionStorage.setItem(SESSION_KEY, 'true');
        showApp();
      } else {
        document.getElementById('loginError').style.display = 'block';
        document.getElementById('pinInput').value = '';
        document.getElementById('pinInput').focus();
      }
    }
    
    async function showApp() {
      document.getElementById('loginScreen').style.display = 'none';
      document.getElementById('appContent').style.display = 'block';
      initSupabase();
      await loadData();
      // Refresh prices on load
      setTimeout(() => refreshPrices(), 500);
    }
    
    document.getElementById('pinInput').addEventListener('keypress', function(e) {
      if (e.key === 'Enter') checkPin();
    });
    
    // ==================== SUPABASE ====================
    function initSupabase() {
      console.log('Initializing Supabase...', { url: supabaseUrl, hasKey: !!supabaseKey });
      if (supabaseUrl && supabaseKey && window.supabase) {
        try {
          supabaseClient = window.supabase.createClient(supabaseUrl, supabaseKey);
          document.getElementById('configNotice').style.display = 'none';
          console.log('Supabase client created successfully');
        } catch (e) {
          console.error('Supabase init failed:', e);
          supabaseClient = null;
          document.getElementById('configNotice').style.display = 'block';
        }
      } else {
        console.log('Supabase not available:', { hasUrl: !!supabaseUrl, hasKey: !!supabaseKey, hasLib: !!window.supabase });
        document.getElementById('configNotice').style.display = 'block';
      }
    }
    
    async function loadData() {
      console.log('loadData() called, supabase client:', !!supabaseClient);
      console.log('Current data.holdings.length:', data.holdings?.length);
      
      let loadedFromSupabase = false;
      
      if (supabaseClient) {
        try {
          console.log('Fetching from Supabase...');
          
          // Fetch all data
          const [holdingsRes, pricesRes, settingsRes, snapshotsRes, thesesRes, watchlistRes, transactionsRes, notesRes, macroRes] = await Promise.all([
            supabaseClient.from('holdings').select('*'),
            supabaseClient.from('prices').select('*'),
            supabaseClient.from('settings').select('*'),
            supabaseClient.from('snapshots').select('*').order('date', { ascending: true }),
            supabaseClient.from('theses').select('*'),
            supabaseClient.from('watchlist').select('*'),
            supabaseClient.from('transactions').select('*').order('date', { ascending: false }),
            supabaseClient.from('notes').select('*').order('created_at', { ascending: false }),
            supabaseClient.from('macro_indicators').select('*'),
          ]);
          
          console.log('Supabase responses:', { 
            holdings: holdingsRes.data?.length, 
            prices: pricesRes.data?.length,
            holdingsError: holdingsRes.error,
            pricesError: pricesRes.error
          });
          
          // Only proceed if we got holdings
          if (holdingsRes.data && holdingsRes.data.length > 0) {
            loadedFromSupabase = true;
            
            // Build price map
            const priceMap = {};
            if (pricesRes.data) {
              pricesRes.data.forEach(p => { priceMap[p.symbol] = parseFloat(p.price); });
            }
            
            // Update data object
            data.holdings = holdingsRes.data.map(h => ({
              symbol: h.symbol,
              name: h.name,
              shares: parseFloat(h.shares),
              price: priceMap[h.symbol] || 0,
              type: h.type
            }));
            
            if (settingsRes.data?.length) {
              const cashSetting = settingsRes.data.find(s => s.key === 'cash');
              if (cashSetting) data.cash = parseFloat(cashSetting.value);
            }
            
            if (snapshotsRes.data?.length) {
              data.weeklyValues = snapshotsRes.data.map(s => ({ date: s.date, value: parseFloat(s.total_value) }));
            }
            
            if (thesesRes.data?.length) {
              data.theses = thesesRes.data.map(t => ({ symbol: t.symbol, thesis: t.thesis, conviction: t.conviction, target: t.target_price }));
            }
            
            if (watchlistRes.data?.length) {
              data.watchlist = watchlistRes.data.map(w => ({ symbol: w.symbol, notes: w.notes, target: w.target_entry }));
            }
            
            if (transactionsRes.data?.length) {
              data.transactions = transactionsRes.data.map(t => ({ id: t.id, symbol: t.symbol, action: t.action, shares: parseFloat(t.shares), price: parseFloat(t.price), date: t.date, notes: t.notes }));
            }
            
            if (notesRes.data?.length) {
              data.notes = notesRes.data.map(n => ({ date: n.created_at.split('T')[0], author: n.author, text: n.content, tags: n.tags || [] }));
            }
            
            if (macroRes.data?.length) {
              data.macroIndicators = macroRes.data.map(m => ({ id: m.id, name: m.name, value: m.value, trend: m.trend }));
            }
            
            data.lastUpdated = new Date().toISOString();
            console.log('‚úÖ Data loaded from Supabase:', data.holdings.length, 'holdings');
          } else {
            console.log('‚ö†Ô∏è Supabase returned empty holdings, using defaults');
          }
        } catch (e) {
          console.error('‚ùå Supabase error:', e);
        }
      } else {
        console.log('‚ö†Ô∏è No Supabase client available');
      }
      
      // Ensure we have valid data - reset to defaults if something is wrong
      if (!data.holdings || data.holdings.length === 0) {
        console.log('üîÑ Resetting to DEFAULT_DATA');
        data = JSON.parse(JSON.stringify(DEFAULT_DATA));
      }
      
      console.log('üìä Final data state:', { 
        holdings: data.holdings?.length,
        cash: data.cash,
        source: loadedFromSupabase ? 'Supabase' : 'Defaults'
      });
      
      // Render
      try {
        initChart();
        render();
        console.log('‚úÖ Render complete');
        
        // Load latest Pinky analysis
        loadLatestAnalysis();
        
        // Load AI recommendations
        loadRecommendations();
        
        // Load investment framework
        loadFramework();
        
        // Load high conviction plays
        loadConviction();
        
        // Fetch live prices in background after initial render
        fetchLivePrices();
      } catch (e) {
        console.error('‚ùå Render error:', e);
        // Last resort - show something
        alert('Error loading dashboard. Check console for details.');
      }
    }
    
    function saveLocal() {
      data.lastUpdated = new Date().toISOString();
      localStorage.setItem('portfolio-dashboard-v3', JSON.stringify(data));
    }
    
    // ==================== LIVE DATA UPDATES ====================
    async function fetchYahooQuote(symbol) {
      try {
        const url = `https://query1.finance.yahoo.com/v8/finance/chart/${symbol}?interval=1d&range=5d`;
        const proxyUrl = `https://api.allorigins.win/raw?url=${encodeURIComponent(url)}`;
        const res = await fetch(proxyUrl, { signal: AbortSignal.timeout(5000) });
        if (res.ok) {
          const json = await res.json();
          return json?.chart?.result?.[0]?.meta?.regularMarketPrice || null;
        }
      } catch (e) { }
      return null;
    }
    
    async function fetchLivePrices() {
      console.log('üì° Fetching live portfolio prices...');
      
      try {
        // Crypto from CoinGecko
        const cryptoIds = { 'BTC': 'bitcoin', 'SOL': 'solana', 'ETH': 'ethereum' };
        const cryptoRes = await fetch('https://api.coingecko.com/api/v3/simple/price?ids=bitcoin,solana,ethereum&vs_currencies=usd');
        if (cryptoRes.ok) {
          const cryptoData = await cryptoRes.json();
          data.holdings.forEach(h => {
            const coinId = cryptoIds[h.symbol];
            if (coinId && cryptoData[coinId]?.usd) {
              h.price = cryptoData[coinId].usd;
              console.log(`‚úÖ ${h.symbol}: $${h.price}`);
            }
          });
        }
        
        // Stock prices from Yahoo
        const stockSymbols = data.holdings.filter(h => h.type === 'stock').map(h => h.symbol);
        for (const symbol of stockSymbols) {
          const price = await fetchYahooQuote(symbol);
          if (price) {
            const holding = data.holdings.find(h => h.symbol === symbol);
            if (holding) {
              holding.price = price;
              console.log(`‚úÖ ${symbol}: $${price}`);
            }
          }
        }
        
        // Update Supabase with new prices
        if (supabaseClient) {
          for (const h of data.holdings) {
            await supabaseClient.from('prices').upsert({ symbol: h.symbol, price: h.price, updated_at: new Date().toISOString() }, { onConflict: 'symbol' });
          }
          console.log('üíæ Prices saved to Supabase');
        }
        
        data.lastUpdated = new Date().toISOString();
        saveLocal();
        render();
        console.log('‚úÖ Live data updated!');
        
      } catch (e) {
        console.error('‚ùå Data fetch error:', e);
      }
    }
    
    // ==================== HELPERS ====================
    function formatCurrency(n) {
      return '$' + n.toLocaleString('en-US', { minimumFractionDigits: 0, maximumFractionDigits: 0 });
    }
    
    function formatDate(dateStr) {
      return new Date(dateStr).toLocaleDateString('en-GB', { day: 'numeric', month: 'short', year: 'numeric' });
    }
    
    function calculateTotals() {
      const stocksValue = data.holdings.filter(h => h.type === 'stock').reduce((sum, h) => sum + h.shares * h.price, 0);
      const cryptoValue = data.holdings.filter(h => h.type === 'crypto').reduce((sum, h) => sum + h.shares * h.price, 0);
      const totalValue = stocksValue + cryptoValue;
      return { stocksValue, cryptoValue, totalValue };
    }
    
    // ==================== LIVE PRICE REFRESH ====================
    const COINGECKO_IDS = {
      'BTC': 'bitcoin', 'SOL': 'solana', 'SUI': 'sui', 'ETH': 'ethereum',
      'RENDER': 'render-token', 'JUP': 'jupiter-exchange-solana', 'LINK': 'chainlink', 'BONK': 'bonk'
    };
    
    async function refreshPrices() {
      console.log('üîÑ Refreshing prices...');
      const statusEl = document.getElementById('priceStatus');
      if (statusEl) statusEl.textContent = 'Updating...';
      
      let cryptoUpdated = false;
      let stocksUpdated = false;
      
      try {
        const cryptoHoldings = data.holdings.filter(h => h.type === 'crypto');
        const stockHoldings = data.holdings.filter(h => h.type === 'stock');
        
        // Fetch crypto prices from CoinGecko (reliable, CORS-friendly)
        if (cryptoHoldings.length > 0) {
          const cgIds = cryptoHoldings.map(h => COINGECKO_IDS[h.symbol]).filter(Boolean);
          if (cgIds.length > 0) {
            try {
              const cgUrl = `https://api.coingecko.com/api/v3/simple/price?ids=${cgIds.join(',')}&vs_currencies=usd`;
              const cgRes = await fetch(cgUrl);
              if (cgRes.ok) {
                const cgData = await cgRes.json();
                cryptoHoldings.forEach(h => {
                  const cgId = COINGECKO_IDS[h.symbol];
                  if (cgId && cgData[cgId]?.usd) {
                    h.price = cgData[cgId].usd;
                  }
                });
                cryptoUpdated = true;
                console.log('‚úÖ Crypto prices updated');
              }
            } catch (e) { console.log('‚ö†Ô∏è CoinGecko failed:', e); }
          }
        }
        
        // Fetch stock prices via corsproxy.io (more reliable)
        if (stockHoldings.length > 0) {
          const symbols = stockHoldings.map(h => h.symbol).join(',');
          
          // Try multiple proxies
          const proxies = [
            `https://corsproxy.io/?${encodeURIComponent(`https://query1.finance.yahoo.com/v7/finance/quote?symbols=${symbols}`)}`,
            `https://api.codetabs.com/v1/proxy?quest=https://query1.finance.yahoo.com/v7/finance/quote?symbols=${symbols}`
          ];
          
          for (const proxyUrl of proxies) {
            try {
              const yahooRes = await fetch(proxyUrl, { timeout: 5000 });
              if (yahooRes.ok) {
                const yahooData = await yahooRes.json();
                if (yahooData.quoteResponse?.result) {
                  yahooData.quoteResponse.result.forEach(quote => {
                    const holding = stockHoldings.find(h => h.symbol === quote.symbol);
                    if (holding && quote.regularMarketPrice) {
                      holding.price = quote.regularMarketPrice;
                    }
                  });
                  stocksUpdated = true;
                  console.log('‚úÖ Stock prices updated');
                  break;
                }
              }
            } catch (e) { console.log('‚ö†Ô∏è Proxy failed, trying next...'); }
          }
        }
        
        // Update Supabase if anything changed
        if ((cryptoUpdated || stocksUpdated) && supabase) {
          const updates = data.holdings.map(h => ({
            symbol: h.symbol,
            price: h.price,
            updated_at: new Date().toISOString()
          }));
          await supabaseClient.from('prices').upsert(updates, { onConflict: 'symbol' });
        }
        
        data.lastPriceUpdate = new Date().toISOString();
        const status = cryptoUpdated || stocksUpdated 
          ? `Updated ${new Date().toLocaleTimeString()}` 
          : 'Using cached prices';
        if (statusEl) statusEl.textContent = status;
        render();
        
      } catch (err) {
        console.error('Price refresh error:', err);
        if (statusEl) statusEl.textContent = 'Using cached prices';
        render(); // Still render with existing data
      }
    }
    
    function calculateYTD() {
      const currentYear = new Date().getFullYear();
      const ytdSnapshots = data.weeklyValues.filter(v => new Date(v.date).getFullYear() === currentYear);
      
      if (ytdSnapshots.length === 0) return { change: 0, percent: 0, startValue: 0 };
      
      const startValue = ytdSnapshots[0].value;
      const { totalValue } = calculateTotals();
      const change = totalValue - startValue;
      const percent = startValue > 0 ? (change / startValue) * 100 : 0;
      
      return { change, percent, startValue, currentValue: totalValue };
    }
    
    // ==================== CHART ====================
    let valueChart = null;
    
    function initChart() {
      const ctx = document.getElementById('valueChart')?.getContext('2d');
      if (!ctx) return;
      
      if (valueChart) valueChart.destroy();
      
      // Filter to YTD only and add current value as latest point
      const currentYear = new Date().getFullYear();
      const ytdValues = data.weeklyValues.filter(v => new Date(v.date).getFullYear() === currentYear);
      
      // Add today's live value as the last point
      const { totalValue } = calculateTotals();
      const today = new Date().toISOString().split('T')[0];
      const lastSnapshot = ytdValues[ytdValues.length - 1];
      if (!lastSnapshot || lastSnapshot.date !== today) {
        ytdValues.push({ date: today, value: totalValue });
      }
      
      valueChart = new Chart(ctx, {
        type: 'line',
        data: {
          labels: ytdValues.map(v => formatDate(v.date)),
          datasets: [{
            label: 'Portfolio Value',
            data: ytdValues.map(v => v.value),
            borderColor: '#58a6ff',
            backgroundColor: 'rgba(88, 166, 255, 0.1)',
            fill: true,
            tension: 0.3
          }]
        },
        options: {
          responsive: true,
          plugins: { legend: { display: false } },
          scales: {
            y: {
              ticks: { color: '#8b949e', callback: v => '$' + (v/1000) + 'k' },
              grid: { color: '#21262d' }
            },
            x: {
              ticks: { color: '#8b949e' },
              grid: { display: false }
            }
          }
        }
      });
    }
    
    // ==================== RENDER ====================
    function render() {
      const { stocksValue, cryptoValue, totalValue } = calculateTotals();
      
      // Summary bar
      document.getElementById('totalValue').textContent = formatCurrency(totalValue);
      document.getElementById('positionCount').textContent = data.holdings.length;
      document.getElementById('lastUpdated').textContent = formatDate(data.lastUpdated);
      
      // Overview stats
      document.getElementById('statStocks').textContent = formatCurrency(stocksValue);
      document.getElementById('statCrypto').textContent = formatCurrency(cryptoValue);
      
      // YTD calculation
      const ytd = calculateYTD();
      const ytdEl = document.getElementById('statYTD');
      if (ytdEl) {
        if (ytd.startValue > 0) {
          const sign = ytd.percent >= 0 ? '+' : '';
          ytdEl.textContent = `${sign}${ytd.percent.toFixed(1)}%`;
          ytdEl.className = 'stat-value ' + (ytd.percent >= 0 ? 'positive' : 'negative');
        } else {
          ytdEl.textContent = '-';
        }
      }
      
      // Top holdings
      const sorted = [...data.holdings].sort((a, b) => (b.shares * b.price) - (a.shares * a.price)).slice(0, 6);
      document.getElementById('topHoldings').innerHTML = sorted.map(h => `
        <div class="holding-item">
          <div>
            <div class="holding-ticker">${h.symbol}</div>
            <div class="holding-name">${h.name}</div>
          </div>
          <div class="holding-value">
            <div>${formatCurrency(h.shares * h.price)}</div>
            <div class="holding-shares">${h.shares.toFixed(2)} @ $${h.price.toLocaleString()}</div>
          </div>
        </div>
      `).join('');
      
      // Pinky's latest analysis
      renderLatestAnalysis();
      
      // Holdings tables - split by type
      // Company/asset descriptions
      const descriptions = {
        'TSLA': 'Electric vehicles, energy storage, and AI-powered autonomous driving',
        'NVDA': 'AI chips and GPU computing leader powering data centers worldwide',
        'MSTR': 'Business intelligence software company and largest corporate Bitcoin holder',
        'HIMS': 'Telehealth platform for personalized health and wellness treatments',
        'ANET': 'Cloud networking solutions for data centers and enterprises',
        'SNOW': 'Cloud data platform for analytics, data sharing, and AI workloads',
        'FTNT': 'Cybersecurity solutions including firewalls and network security',
        'MRVL': 'Semiconductors for data infrastructure, 5G, and cloud computing',
        'BTC': 'Decentralized digital currency and store of value',
        'SOL': 'High-speed blockchain for DeFi, NFTs, and decentralized apps',
        'ETH': 'Programmable blockchain powering smart contracts and DeFi',
      };
      
      const stocks = data.holdings.filter(h => h.type === 'stock').sort((a, b) => (b.shares * b.price) - (a.shares * a.price));
      const crypto = data.holdings.filter(h => h.type === 'crypto').sort((a, b) => (b.shares * b.price) - (a.shares * a.price));
      const totalInvestedValue = data.holdings.reduce((sum, h) => sum + h.shares * h.price, 0);
      
      document.getElementById('stocksTable').innerHTML = stocks.map(h => {
        const value = h.shares * h.price;
        const pct = totalInvestedValue > 0 ? ((value / totalInvestedValue) * 100).toFixed(1) : 0;
        const desc = descriptions[h.symbol] || '';
        return `
        <tr>
          <td class="ticker">${h.symbol}</td>
          <td>
            <div>${h.name}</div>
            ${desc ? `<div style="font-size: 0.75rem; color: #8b949e; margin-top: 2px;">${desc}</div>` : ''}
          </td>
          <td>${h.shares.toFixed(2)}</td>
          <td>$${h.price.toLocaleString()}</td>
          <td>${formatCurrency(value)}</td>
          <td>${pct}%</td>
          <td><button class="btn btn-secondary" onclick="deleteHolding('${h.symbol}')">√ó</button></td>
        </tr>`;
      }).join('') || '<tr><td colspan="7" style="text-align:center;color:#8b949e;">No stocks</td></tr>';
      
      document.getElementById('cryptoTable').innerHTML = crypto.map(h => {
        const value = h.shares * h.price;
        const pct = totalInvestedValue > 0 ? ((value / totalInvestedValue) * 100).toFixed(1) : 0;
        const desc = descriptions[h.symbol] || '';
        return `
        <tr>
          <td class="ticker">${h.symbol}</td>
          <td>
            <div>${h.name}</div>
            ${desc ? `<div style="font-size: 0.75rem; color: #8b949e; margin-top: 2px;">${desc}</div>` : ''}
          </td>
          <td>${h.shares.toFixed(2)}</td>
          <td>$${h.price.toLocaleString()}</td>
          <td>${formatCurrency(value)}</td>
          <td>${pct}%</td>
          <td><button class="btn btn-secondary" onclick="deleteHolding('${h.symbol}')">√ó</button></td>
        </tr>`;
      }).join('') || '<tr><td colspan="7" style="text-align:center;color:#8b949e;">No crypto</td></tr>';
      
      // Transactions
      document.getElementById('transactionLog').innerHTML = data.transactions.map((t, idx) => `
        <div class="watchlist-item">
          <div>
            <div class="watchlist-ticker">${t.action.toUpperCase()} ${t.shares} ${t.symbol}</div>
            <div class="watchlist-note">${formatDate(t.date)} @ $${t.price}${t.notes ? ' ‚Äî ' + t.notes : ''}</div>
          </div>
          <div style="display:flex;align-items:center;gap:10px;">
            <span class="${t.action === 'buy' ? 'negative' : 'positive'}">${formatCurrency(t.shares * t.price)}</span>
            <button class="btn btn-secondary" onclick="editTransaction(${idx})" title="Edit">‚úèÔ∏è</button>
            <button class="btn btn-secondary" onclick="deleteTransaction(${idx})" title="Delete">√ó</button>
          </div>
        </div>
      `).join('') || '<p style="color:#8b949e;">No transactions logged.</p>';
      
      // Watchlist
      document.getElementById('watchlistItems').innerHTML = [...data.watchlist]
        .sort((a, b) => a.symbol.localeCompare(b.symbol))
        .map((w) => {
          const originalIdx = data.watchlist.findIndex(item => item.symbol === w.symbol);
          return `
          <div class="watchlist-item">
            <div>
              <div class="watchlist-ticker">${w.symbol}</div>
              <div class="watchlist-note">${w.notes || ''}</div>
            </div>
            <div style="display: flex; align-items: center; gap: 10px;">
              ${w.target ? `<span style="color:#8b949e;">Target: $${w.target}</span>` : ''}
              <button class="btn btn-secondary" onclick="editWatchlistItem(${originalIdx})" title="Edit">‚úèÔ∏è</button>
              <button class="btn btn-secondary" onclick="deleteWatchlistItem(${originalIdx})" title="Delete">√ó</button>
            </div>
          </div>
        `;
        }).join('') || '<p style="color:#8b949e;">Watchlist empty.</p>';
      
      // Watchlist Analysis
      renderWatchlistAnalysis();
      
      // Notes
      document.getElementById('notesList').innerHTML = data.notes.map((n, idx) => `
        <div class="note-card">
          <div class="note-meta" style="display: flex; justify-content: space-between; align-items: center;">
            <div>
              <span class="note-author">${n.author === 'pinky' ? 'üß† Pinky' : 'üë§ Chris'}</span>
              <span>${formatDate(n.date)}</span>
            </div>
            <div style="display: flex; gap: 5px;">
              <button class="btn btn-secondary" onclick="editNote(${idx})" title="Edit" style="padding: 4px 8px;">‚úèÔ∏è</button>
              <button class="btn btn-secondary" onclick="deleteNote(${idx})" title="Delete" style="padding: 4px 8px;">√ó</button>
            </div>
          </div>
          <div class="note-text">${n.text}</div>
          ${n.tags?.length ? `<div class="note-tags">${n.tags.map(t => `<span class="tag">${t}</span>`).join('')}</div>` : ''}
        </div>
      `).join('') || '<p style="color:#8b949e;">No notes yet.</p>';
      
      // Earnings
      renderEarnings();
      
      // Update chart
      if (valueChart) {
        const currentYear = new Date().getFullYear();
        const ytdValues = data.weeklyValues.filter(v => new Date(v.date).getFullYear() === currentYear);
        
        // Add today's live value as the last point
        const { totalValue } = calculateTotals();
        const today = new Date().toISOString().split('T')[0];
        const lastSnapshot = ytdValues[ytdValues.length - 1];
        if (!lastSnapshot || lastSnapshot.date !== today) {
          ytdValues.push({ date: today, value: totalValue });
        }
        
        valueChart.data.labels = ytdValues.map(v => formatDate(v.date));
        valueChart.data.datasets[0].data = ytdValues.map(v => v.value);
        valueChart.update();
      }
    }
    
    // ==================== ASK PINKY ====================
    // Store the latest analysis locally and in Supabase
    let latestAnalysis = JSON.parse(localStorage.getItem('pinky-latest-analysis') || 'null');
    
    function formatAnalysisText(raw) {
      // Split by section headers
      const sections = raw.split(/\*\*([üìäüì∞üìÖüìàüß†üéØ][^*]+)\*\*/g);
      
      let html = '';
      for (let i = 0; i < sections.length; i++) {
        const part = sections[i].trim();
        if (!part) continue;
        
        // Check if this is a header (starts with emoji)
        if (/^[üìäüì∞üìÖüìàüß†üéØ]/.test(part)) {
          html += `<h4>${part}</h4>`;
        } else {
          // Content section - format bullet points
          let content = part
            // Convert - or ‚Ä¢ bullet points to list items
            .replace(/^[-‚Ä¢]\s*/gm, '<li>')
            .replace(/\n[-‚Ä¢]\s*/g, '</li><li>')
            // Bold text
            .replace(/\*\*([^*]+)\*\*/g, '<strong>$1</strong>')
            // Line breaks
            .replace(/\n\n/g, '</p><p>')
            .replace(/\n/g, ' ');
          
          // Wrap bullets in ul
          if (content.includes('<li>')) {
            content = '<ul>' + content + '</li></ul>';
            content = content.replace(/<\/ul>\s*<ul>/g, '');
          } else if (content.trim()) {
            content = '<p>' + content + '</p>';
          }
          
          html += content;
        }
      }
      
      // Clean up empty tags
      html = html
        .replace(/<p>\s*<\/p>/g, '')
        .replace(/<ul>\s*<\/ul>/g, '')
        .replace(/<li>\s*<\/li>/g, '');
      
      return html || '<p>' + raw + '</p>';
    }
    
    function renderLatestAnalysis() {
      const card = document.getElementById('latestAnalysisCard');
      const text = document.getElementById('latestAnalysisText');
      const timestamp = document.getElementById('analysisTimestamp');
      const noMsg = document.getElementById('noAnalysisMsg');
      
      if (latestAnalysis && latestAnalysis.text) {
        card.style.display = 'block';
        noMsg.style.display = 'none';
        text.innerHTML = formatAnalysisText(latestAnalysis.text);
        timestamp.textContent = formatDate(latestAnalysis.timestamp);
      } else {
        card.style.display = 'none';
        noMsg.style.display = 'block';
      }
    }
    
    async function loadLatestAnalysis() {
      // Try to load from Supabase first
      if (supabaseClient) {
        try {
          const { data: analyses } = await supabaseClient
            .from('pinky_analysis')
            .select('*')
            .order('created_at', { ascending: false })
            .limit(1);
          
          if (analyses && analyses.length > 0) {
            latestAnalysis = {
              text: analyses[0].content,
              timestamp: analyses[0].created_at
            };
            localStorage.setItem('pinky-latest-analysis', JSON.stringify(latestAnalysis));
          }
        } catch (e) {
          console.log('Could not load analysis from Supabase:', e);
        }
      }
      renderLatestAnalysis();
    }
    
    async function saveAnalysis(text, timestamp) {
      latestAnalysis = { text, timestamp };
      localStorage.setItem('pinky-latest-analysis', JSON.stringify(latestAnalysis));
      
      // Save to Supabase (overwrite by deleting old and inserting new)
      if (supabaseClient) {
        try {
          // Delete all old analyses
          await supabaseClient.from('pinky_analysis').delete().neq('id', 0);
          // Insert new one
          await supabaseClient.from('pinky_analysis').insert({
            content: text,
            created_at: timestamp
          });
        } catch (e) {
          console.log('Could not save analysis to Supabase:', e);
        }
      }
      
      renderLatestAnalysis();
    }
    
    async function askPinky(type) {
      const btn = document.getElementById(type === 'macro' ? 'askMacroBtn' : 'askQuickBtn');
      
      // For quick analysis, show loading in the card
      if (type === 'quick') {
        const card = document.getElementById('latestAnalysisCard');
        const text = document.getElementById('latestAnalysisText');
        const timestamp = document.getElementById('analysisTimestamp');
        const noMsg = document.getElementById('noAnalysisMsg');
        
        card.style.display = 'block';
        noMsg.style.display = 'none';
        text.textContent = 'Analyzing your top 5 holdings...';
        timestamp.textContent = 'Loading...';
      }
      
      // For macro, use the old response div
      const responseDiv = document.getElementById('macroResponse');
      const responseText = document.getElementById('macroResponseText');
      if (type === 'macro') {
        responseDiv.classList.add('active');
        responseText.textContent = 'Analyzing market conditions...';
      }
      
      btn.disabled = true;
      btn.innerHTML = '‚è≥ Analyzing...';
      
      try {
        // Build context
        const { stocksValue, cryptoValue, totalValue } = calculateTotals();
        
        // Call the API endpoint
        const selectedModel = document.getElementById('aiModelSelect')?.value || 'anthropic';
        
        const response = await fetch('/api/analyze', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            holdings: data.holdings,
            totalValue,
            stocksValue,
            cryptoValue,
            type,
            model: selectedModel
          })
        });
        
        const result = await response.json();
        
        if (result.error) {
          if (type === 'quick') {
            document.getElementById('latestAnalysisText').textContent = `‚ùå Error: ${result.error}`;
          } else {
            responseText.textContent = `‚ùå Error: ${result.error}`;
          }
        } else {
          if (type === 'quick') {
            // Save and display the new analysis
            await saveAnalysis(result.analysis, result.timestamp || new Date().toISOString());
          } else {
            responseText.textContent = result.analysis;
          }
        }
        
      } catch (error) {
        console.error('Analysis error:', error);
        const errorMsg = `‚ùå Error: ${error.message}. Try again later.`;
        if (type === 'quick') {
          document.getElementById('latestAnalysisText').textContent = errorMsg;
        } else {
          responseText.textContent = errorMsg;
        }
      }
      
      btn.disabled = false;
      btn.innerHTML = type === 'macro' ? 'üîÆ Analyze Market & Portfolio' : 'üîÆ Quick Analysis';
    }
    
    // ==================== AI RECOMMENDATIONS (Holdings Page) ====================
    let storedRecommendations = {
      highRisk: JSON.parse(localStorage.getItem('pinky-high-risk') || 'null'),
      rebalance: JSON.parse(localStorage.getItem('pinky-rebalance') || 'null')
    };
    
    function renderRecommendation(type) {
      const data = storedRecommendations[type];
      const card = document.getElementById(type === 'highRisk' ? 'highRiskCard' : 'rebalanceCard');
      const text = document.getElementById(type === 'highRisk' ? 'highRiskText' : 'rebalanceText');
      const timestamp = document.getElementById(type === 'highRisk' ? 'highRiskTimestamp' : 'rebalanceTimestamp');
      const noMsg = document.getElementById(type === 'highRisk' ? 'noHighRiskMsg' : 'noRebalanceMsg');
      
      if (data && data.text) {
        card.style.display = 'block';
        noMsg.style.display = 'none';
        text.innerHTML = formatAnalysisText(data.text);
        timestamp.textContent = formatDate(data.timestamp);
      } else {
        card.style.display = 'none';
        noMsg.style.display = 'block';
      }
    }
    
    async function loadRecommendations() {
      // Try to load from Supabase
      if (supabaseClient) {
        try {
          const { data: recs } = await supabaseClient
            .from('ai_recommendations')
            .select('*')
            .order('created_at', { ascending: false });
          
          if (recs) {
            recs.forEach(r => {
              if (r.type === 'highRisk' || r.type === 'rebalance') {
                storedRecommendations[r.type] = { text: r.content, timestamp: r.created_at };
                localStorage.setItem(`pinky-${r.type === 'highRisk' ? 'high-risk' : 'rebalance'}`, 
                  JSON.stringify(storedRecommendations[r.type]));
              }
            });
          }
        } catch (e) {
          console.log('Could not load recommendations from Supabase:', e);
        }
      }
      renderRecommendation('highRisk');
      renderRecommendation('rebalance');
    }
    
    async function saveRecommendation(type, text, timestamp) {
      storedRecommendations[type] = { text, timestamp };
      localStorage.setItem(`pinky-${type === 'highRisk' ? 'high-risk' : 'rebalance'}`, 
        JSON.stringify(storedRecommendations[type]));
      
      if (supabaseClient) {
        try {
          await supabaseClient.from('ai_recommendations').delete().eq('type', type);
          await supabaseClient.from('ai_recommendations').insert({
            type,
            content: text,
            created_at: timestamp
          });
        } catch (e) {
          console.log('Could not save recommendation to Supabase:', e);
        }
      }
      
      renderRecommendation(type);
    }
    
    async function getAIRecommendations(type) {
      const btn = document.getElementById(type === 'highRisk' ? 'highRiskBtn' : 'rebalanceBtn');
      const card = document.getElementById(type === 'highRisk' ? 'highRiskCard' : 'rebalanceCard');
      const text = document.getElementById(type === 'highRisk' ? 'highRiskText' : 'rebalanceText');
      const timestamp = document.getElementById(type === 'highRisk' ? 'highRiskTimestamp' : 'rebalanceTimestamp');
      const noMsg = document.getElementById(type === 'highRisk' ? 'noHighRiskMsg' : 'noRebalanceMsg');
      
      btn.disabled = true;
      btn.innerHTML = '‚è≥ Analyzing...';
      card.style.display = 'block';
      noMsg.style.display = 'none';
      text.textContent = type === 'highRisk' ? 'Finding high risk/reward opportunities...' : 'Analyzing portfolio for rebalancing...';
      timestamp.textContent = 'Loading...';
      
      try {
        const { stocksValue, cryptoValue, totalValue } = calculateTotals();
        
        const response = await fetch('/api/recommend', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            holdings: data.holdings,
            totalValue,
            stocksValue,
            cryptoValue,
            type
          })
        });
        
        const result = await response.json();
        
        if (result.error) {
          text.textContent = `‚ùå Error: ${result.error}`;
        } else {
          await saveRecommendation(type, result.analysis, result.timestamp || new Date().toISOString());
        }
        
      } catch (error) {
        console.error('Recommendation error:', error);
        text.textContent = `‚ùå Error: ${error.message}. Try again later.`;
      }
      
      btn.disabled = false;
      btn.innerHTML = type === 'highRisk' ? 'üé≤ Get Ideas' : 'üîÑ Analyze';
    }
    
    // ==================== INVESTMENT FRAMEWORK ====================
    let storedFramework = JSON.parse(localStorage.getItem('pinky-framework') || 'null');
    
    function renderFramework() {
      const card = document.getElementById('frameworkCard');
      const text = document.getElementById('frameworkText');
      const timestamp = document.getElementById('frameworkTimestamp');
      const noMsg = document.getElementById('noFrameworkMsg');
      
      if (storedFramework && storedFramework.text) {
        card.style.display = 'block';
        noMsg.style.display = 'none';
        text.innerHTML = formatAnalysisText(storedFramework.text);
        timestamp.textContent = formatDate(storedFramework.timestamp);
      } else {
        card.style.display = 'none';
        noMsg.style.display = 'block';
      }
    }
    
    async function loadFramework() {
      if (supabaseClient) {
        try {
          const { data: frameworks } = await supabaseClient
            .from('ai_recommendations')
            .select('*')
            .eq('type', 'framework')
            .order('created_at', { ascending: false })
            .limit(1);
          
          if (frameworks && frameworks.length > 0) {
            storedFramework = { text: frameworks[0].content, timestamp: frameworks[0].created_at };
            localStorage.setItem('pinky-framework', JSON.stringify(storedFramework));
          }
        } catch (e) {
          console.log('Could not load framework from Supabase:', e);
        }
      }
      renderFramework();
    }
    
    async function runFrameworkAnalysis() {
      const btn = document.getElementById('frameworkBtn');
      const card = document.getElementById('frameworkCard');
      const text = document.getElementById('frameworkText');
      const timestamp = document.getElementById('frameworkTimestamp');
      const noMsg = document.getElementById('noFrameworkMsg');
      
      btn.disabled = true;
      btn.innerHTML = '‚è≥ Generating Framework...';
      card.style.display = 'block';
      noMsg.style.display = 'none';
      text.textContent = 'Generating comprehensive investment framework (this may take 30-60 seconds)...';
      timestamp.textContent = 'Loading...';
      
      try {
        const response = await fetch('/api/recommend', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ type: 'framework' })
        });
        
        const result = await response.json();
        
        if (result.error) {
          text.textContent = `‚ùå Error: ${result.error}`;
        } else {
          storedFramework = { text: result.analysis, timestamp: result.timestamp || new Date().toISOString() };
          localStorage.setItem('pinky-framework', JSON.stringify(storedFramework));
          
          if (supabaseClient) {
            try {
              await supabaseClient.from('ai_recommendations').delete().eq('type', 'framework');
              await supabaseClient.from('ai_recommendations').insert({
                type: 'framework',
                content: result.analysis,
                created_at: storedFramework.timestamp
              });
            } catch (e) {
              console.log('Could not save framework to Supabase:', e);
            }
          }
          
          renderFramework();
        }
        
      } catch (error) {
        console.error('Framework error:', error);
        text.textContent = `‚ùå Error: ${error.message}. Try again later.`;
      }
      
      btn.disabled = false;
      btn.innerHTML = 'üöÄ Run Framework';
    }
    
    // ==================== HIGH CONVICTION PLAYS ====================
    let storedConviction = JSON.parse(localStorage.getItem('pinky-conviction') || 'null');
    
    function renderConviction() {
      const card = document.getElementById('convictionCard');
      const text = document.getElementById('convictionText');
      const timestamp = document.getElementById('convictionTimestamp');
      const noMsg = document.getElementById('noConvictionMsg');
      
      if (storedConviction && storedConviction.text) {
        card.style.display = 'block';
        noMsg.style.display = 'none';
        text.innerHTML = formatAnalysisText(storedConviction.text);
        timestamp.textContent = formatDate(storedConviction.timestamp);
      } else {
        card.style.display = 'none';
        noMsg.style.display = 'block';
      }
    }
    
    async function loadConviction() {
      if (supabaseClient) {
        try {
          const { data: convictions } = await supabaseClient
            .from('ai_recommendations')
            .select('*')
            .eq('type', 'conviction')
            .order('created_at', { ascending: false })
            .limit(1);
          
          if (convictions && convictions.length > 0) {
            storedConviction = { text: convictions[0].content, timestamp: convictions[0].created_at };
            localStorage.setItem('pinky-conviction', JSON.stringify(storedConviction));
          }
        } catch (e) {
          console.log('Could not load conviction from Supabase:', e);
        }
      }
      renderConviction();
    }
    
    async function runConvictionAnalysis() {
      const btn = document.getElementById('convictionBtn');
      const card = document.getElementById('convictionCard');
      const text = document.getElementById('convictionText');
      const timestamp = document.getElementById('convictionTimestamp');
      const noMsg = document.getElementById('noConvictionMsg');
      
      btn.disabled = true;
      btn.innerHTML = '‚è≥ Generating Picks...';
      card.style.display = 'block';
      noMsg.style.display = 'none';
      text.textContent = 'Analyzing markets and generating high conviction picks (this may take 30-60 seconds)...';
      timestamp.textContent = 'Loading...';
      
      try {
        const response = await fetch('/api/recommend', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ type: 'conviction' })
        });
        
        const result = await response.json();
        
        if (result.error) {
          text.textContent = `‚ùå Error: ${result.error}`;
        } else {
          storedConviction = { text: result.analysis, timestamp: result.timestamp || new Date().toISOString() };
          localStorage.setItem('pinky-conviction', JSON.stringify(storedConviction));
          
          if (supabaseClient) {
            try {
              await supabaseClient.from('ai_recommendations').delete().eq('type', 'conviction');
              await supabaseClient.from('ai_recommendations').insert({
                type: 'conviction',
                content: result.analysis,
                created_at: storedConviction.timestamp
              });
            } catch (e) {
              console.log('Could not save conviction to Supabase:', e);
            }
          }
          
          renderConviction();
        }
        
      } catch (error) {
        console.error('Conviction error:', error);
        text.textContent = `‚ùå Error: ${error.message}. Try again later.`;
      }
      
      btn.disabled = false;
      btn.innerHTML = 'üî• Generate Picks';
    }
    
    // ==================== CRUD OPERATIONS ====================
    async function saveHolding() {
      const symbol = document.getElementById('holdingSymbol').value.toUpperCase();
      const name = document.getElementById('holdingName').value;
      const shares = parseFloat(document.getElementById('holdingShares').value);
      const price = parseFloat(document.getElementById('holdingPrice').value);
      const type = document.getElementById('holdingType').value;
      
      if (!symbol || !shares) return alert('Symbol and shares required');
      
      const existing = data.holdings.findIndex(h => h.symbol === symbol);
      if (existing >= 0) {
        data.holdings[existing] = { symbol, name, shares, price, type };
      } else {
        data.holdings.push({ symbol, name, shares, price, type });
      }
      
      if (supabaseClient) {
        await supabaseClient.from('holdings').upsert({ symbol, name, shares, type }, { onConflict: 'symbol' });
        await supabaseClient.from('prices').upsert({ symbol, price }, { onConflict: 'symbol' });
      }
      
      saveLocal();
      render();
      closeModal('holdingModal');
      clearForm('holding');
    }
    
    async function deleteHolding(symbol) {
      if (!confirm(`Delete ${symbol}?`)) return;
      data.holdings = data.holdings.filter(h => h.symbol !== symbol);
      if (supabaseClient) await supabaseClient.from('holdings').delete().eq('symbol', symbol);
      saveLocal();
      render();
    }
    
    let editingNoteIdx = null;
    
    async function saveNote() {
      const author = document.getElementById('noteAuthor').value;
      const text = document.getElementById('noteText').value;
      const tags = document.getElementById('noteTags').value.split(',').map(t => t.trim()).filter(t => t);
      
      if (!text) return alert('Note text required');
      
      if (editingNoteIdx !== null) {
        // Update existing note
        const oldNote = data.notes[editingNoteIdx];
        data.notes[editingNoteIdx] = { ...oldNote, author, text, tags };
        
        if (supabaseClient && oldNote.id) {
          await supabaseClient.from('notes').update({ author, content: text, tags }).eq('id', oldNote.id);
        }
        editingNoteIdx = null;
      } else {
        // Add new note
        const note = { date: new Date().toISOString().split('T')[0], author, text, tags };
        data.notes.unshift(note);
        
        if (supabaseClient) {
          await supabaseClient.from('notes').insert({ author, content: text, tags });
        }
      }
      
      saveLocal();
      render();
      closeModal('noteModal');
      clearForm('note');
    }
    
    function editNote(idx) {
      const n = data.notes[idx];
      if (!n) return;
      editingNoteIdx = idx;
      document.getElementById('noteAuthor').value = n.author || 'chris';
      document.getElementById('noteText').value = n.text || '';
      document.getElementById('noteTags').value = (n.tags || []).join(', ');
      openModal('noteModal');
    }
    
    async function deleteNote(idx) {
      const n = data.notes[idx];
      if (!n || !confirm('Delete this note?')) return;
      
      if (supabaseClient && n.id) {
        await supabaseClient.from('notes').delete().eq('id', n.id);
      }
      
      data.notes.splice(idx, 1);
      saveLocal();
      render();
    }
    
    let editingTransactionIdx = null;
    
    function editTransaction(idx) {
      const t = data.transactions[idx];
      if (!t) return;
      editingTransactionIdx = idx;
      document.getElementById('txSymbol').value = t.symbol;
      document.getElementById('txAction').value = t.action;
      document.getElementById('txShares').value = t.shares;
      document.getElementById('txPrice').value = t.price;
      document.getElementById('txDate').value = t.date;
      openModal('transactionModal');
    }
    
    async function deleteTransaction(idx) {
      const t = data.transactions[idx];
      if (!t || !confirm(`Delete ${t.action} ${t.shares} ${t.symbol}?`)) return;
      
      if (supabaseClient && t.id) {
        await supabaseClient.from('transactions').delete().eq('id', t.id);
      }
      
      data.transactions.splice(idx, 1);
      saveLocal();
      render();
    }
    
    async function saveTransaction() {
      const symbol = document.getElementById('txSymbol').value.toUpperCase();
      const action = document.getElementById('txAction').value;
      const shares = parseFloat(document.getElementById('txShares').value);
      const price = parseFloat(document.getElementById('txPrice').value);
      const date = document.getElementById('txDate').value || new Date().toISOString().split('T')[0];
      
      if (!symbol || !shares || !price) return alert('All fields required');
      
      if (editingTransactionIdx !== null) {
        // Update existing transaction (don't modify holdings for edits)
        const oldTx = data.transactions[editingTransactionIdx];
        const tx = { ...oldTx, symbol, action, shares, price, date };
        data.transactions[editingTransactionIdx] = tx;
        
        if (supabaseClient && oldTx.id) {
          await supabaseClient.from('transactions').update({ symbol, action, shares, price, date }).eq('id', oldTx.id);
        }
        editingTransactionIdx = null;
      } else {
        // Create new transaction AND update holdings
        const tx = { symbol, action, shares, price, date };
        data.transactions.unshift(tx);
        
        // Update holdings based on transaction
        const existingHolding = data.holdings.find(h => h.symbol === symbol);
        if (action === 'buy') {
          if (existingHolding) {
            existingHolding.shares += shares;
            existingHolding.price = price; // Update to latest price
          } else {
            // Create new holding - prompt for name and type
            const name = prompt(`Enter name for ${symbol}:`, symbol);
            const type = prompt(`Type for ${symbol}? (stock/crypto):`, 'stock');
            if (name && type) {
              data.holdings.push({ symbol, name, shares, price, type: type.toLowerCase() });
              if (supabaseClient) {
                await supabaseClient.from('holdings').insert({ symbol, name, shares, type: type.toLowerCase() });
                await supabaseClient.from('prices').upsert({ symbol, price }, { onConflict: 'symbol' });
              }
            }
          }
        } else if (action === 'sell' && existingHolding) {
          existingHolding.shares -= shares;
          if (existingHolding.shares <= 0) {
            // Remove holding if all shares sold
            data.holdings = data.holdings.filter(h => h.symbol !== symbol);
            if (supabaseClient) {
              await supabaseClient.from('holdings').delete().eq('symbol', symbol);
            }
          }
        }
        
        // Update Supabase holdings
        if (supabaseClient && existingHolding && existingHolding.shares > 0) {
          await supabaseClient.from('holdings').update({ shares: existingHolding.shares }).eq('symbol', symbol);
          await supabaseClient.from('prices').upsert({ symbol, price }, { onConflict: 'symbol' });
        }
        
        // Insert transaction
        if (supabaseClient) {
          const { data: inserted } = await supabaseClient.from('transactions').insert({ symbol, action, shares, price, date }).select();
          if (inserted?.[0]) tx.id = inserted[0].id;
        }
      }
      
      saveLocal();
      render();
      closeModal('transactionModal');
      clearForm('transaction');
    }
    
    let editingWatchlistIdx = null;
    
    async function saveWatchlist() {
      const symbol = document.getElementById('watchSymbol').value.toUpperCase();
      const notes = document.getElementById('watchNotes').value;
      const target = parseFloat(document.getElementById('watchTarget').value) || null;
      
      if (!symbol) return alert('Symbol required');
      
      if (editingWatchlistIdx !== null) {
        // Update existing
        const oldSymbol = data.watchlist[editingWatchlistIdx].symbol;
        data.watchlist[editingWatchlistIdx] = { symbol, notes, target };
        
        if (supabaseClient) {
          await supabaseClient.from('watchlist').delete().eq('symbol', oldSymbol);
          await supabaseClient.from('watchlist').insert({ symbol, notes, target_entry: target });
        }
        editingWatchlistIdx = null;
      } else {
        // Add new
        data.watchlist.push({ symbol, notes, target });
        
        if (supabaseClient) {
          await supabaseClient.from('watchlist').insert({ symbol, notes, target_entry: target });
        }
      }
      
      saveLocal();
      render();
      closeModal('watchlistModal');
      clearForm('watchlist');
    }
    
    function editWatchlistItem(idx) {
      const w = data.watchlist[idx];
      if (!w) return;
      editingWatchlistIdx = idx;
      document.getElementById('watchSymbol').value = w.symbol;
      document.getElementById('watchNotes').value = w.notes || '';
      document.getElementById('watchTarget').value = w.target || '';
      openModal('watchlistModal');
    }
    
    async function deleteWatchlistItem(idx) {
      const w = data.watchlist[idx];
      if (!w || !confirm(`Remove ${w.symbol} from watchlist?`)) return;
      
      if (supabaseClient) {
        await supabaseClient.from('watchlist').delete().eq('symbol', w.symbol);
      }
      
      data.watchlist.splice(idx, 1);
      saveLocal();
      render();
    }
    
    async function saveThesis() {
      const symbol = document.getElementById('thesisSymbol').value.toUpperCase();
      const thesis = document.getElementById('thesisText').value;
      const conviction = document.getElementById('thesisConviction').value;
      const target = parseFloat(document.getElementById('thesisTarget').value) || null;
      
      if (!symbol || !thesis) return alert('Symbol and thesis required');
      
      data.theses.push({ symbol, thesis, conviction, target });
      
      if (supabaseClient) {
        await supabaseClient.from('theses').insert({ symbol, thesis, conviction, target_price: target });
      }
      
      saveLocal();
      render();
      closeModal('thesisModal');
      clearForm('thesis');
    }
    
    // ==================== CONFIG ====================
    function showConfigModal() {
      document.getElementById('configUrl').value = supabaseUrl;
      document.getElementById('configKey').value = supabaseKey;
      openModal('configModal');
    }
    
    function saveConfig() {
      supabaseUrl = document.getElementById('configUrl').value.trim();
      supabaseKey = document.getElementById('configKey').value.trim();
      
      localStorage.setItem('supabase_url', supabaseUrl);
      localStorage.setItem('supabase_key', supabaseKey);
      
      initSupabase();
      loadData();
      closeModal('configModal');
    }
    
    // ==================== UI HELPERS ====================
    function openModal(id) {
      document.getElementById(id).classList.add('active');
    }
    
    function closeModal(id) {
      document.getElementById(id).classList.remove('active');
    }
    
    function clearForm(type) {
      if (type === 'holding') {
        ['holdingSymbol', 'holdingName', 'holdingShares', 'holdingPrice'].forEach(id => document.getElementById(id).value = '');
      } else if (type === 'note') {
        ['noteText', 'noteTags'].forEach(id => document.getElementById(id).value = '');
      } else if (type === 'transaction') {
        ['txSymbol', 'txShares', 'txPrice'].forEach(id => document.getElementById(id).value = '');
      } else if (type === 'watchlist') {
        ['watchSymbol', 'watchNotes', 'watchTarget'].forEach(id => document.getElementById(id).value = '');
      } else if (type === 'thesis') {
        ['thesisSymbol', 'thesisText', 'thesisTarget'].forEach(id => document.getElementById(id).value = '');
      }
    }
    
    // Tab navigation
    document.querySelectorAll('.nav-tab').forEach(tab => {
      tab.addEventListener('click', () => {
        document.querySelectorAll('.nav-tab').forEach(t => t.classList.remove('active'));
        document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
        tab.classList.add('active');
        document.getElementById(tab.dataset.tab).classList.add('active');
      });
    });
    
    // Close modals on overlay click
    document.querySelectorAll('.modal-overlay').forEach(m => {
      m.addEventListener('click', e => { if (e.target === m) m.classList.remove('active'); });
    });
    
    document.addEventListener('keydown', e => {
      if (e.key === 'Escape') document.querySelectorAll('.modal-overlay').forEach(m => m.classList.remove('active'));
    });
    
    // Set default date for transactions
    document.getElementById('txDate').value = new Date().toISOString().split('T')[0];
    
    // ==================== EARNINGS CALENDAR ====================
    let earningsData = JSON.parse(localStorage.getItem('earnings-data') || '{}');
    
    function renderEarnings() {
      const tableBody = document.getElementById('earningsTable');
      const thisWeekDiv = document.getElementById('earningsThisWeek');
      
      if (!tableBody) return;
      
      const stockHoldings = data.holdings.filter(h => h.type === 'stock');
      const today = new Date();
      today.setHours(0, 0, 0, 0);
      
      // Build earnings list with dates
      const earningsList = stockHoldings.map(h => {
        const earningsDate = earningsData[h.symbol]?.date;
        const dateObj = earningsDate ? new Date(earningsDate) : null;
        const daysAway = dateObj ? Math.ceil((dateObj - today) / (1000 * 60 * 60 * 24)) : null;
        
        return {
          symbol: h.symbol,
          name: h.name,
          date: earningsDate,
          dateObj,
          daysAway,
          time: earningsData[h.symbol]?.time || 'TBD'
        };
      });
      
      // Sort by date (soonest first, unknown at end)
      earningsList.sort((a, b) => {
        if (!a.dateObj && !b.dateObj) return 0;
        if (!a.dateObj) return 1;
        if (!b.dateObj) return -1;
        return a.dateObj - b.dateObj;
      });
      
      // Render table
      tableBody.innerHTML = earningsList.map(e => {
        let statusClass = '';
        let statusText = '';
        
        if (e.daysAway === null) {
          statusText = '‚ùì Unknown';
          statusClass = '';
        } else if (e.daysAway < 0) {
          statusText = '‚úÖ Reported';
          statusClass = 'positive';
        } else if (e.daysAway === 0) {
          statusText = 'üî¥ TODAY';
          statusClass = 'negative';
        } else if (e.daysAway <= 7) {
          statusText = '‚ö†Ô∏è This Week';
          statusClass = 'negative';
        } else if (e.daysAway <= 14) {
          statusText = 'üìÖ Soon';
          statusClass = '';
        } else {
          statusText = 'üìÜ Upcoming';
          statusClass = '';
        }
        
        return `
          <tr>
            <td>${e.date ? formatDate(e.date) : 'Unknown'}</td>
            <td class="ticker">${e.symbol}</td>
            <td>${e.name}</td>
            <td>${e.daysAway !== null ? (e.daysAway < 0 ? 'Passed' : e.daysAway + ' days') : '-'}</td>
            <td class="${statusClass}">${statusText}</td>
            <td><button class="btn btn-secondary" onclick="editEarningsDate('${e.symbol}')" style="padding: 4px 8px;">‚úèÔ∏è</button></td>
          </tr>
        `;
      }).join('') || '<tr><td colspan="5" style="text-align:center;color:#8b949e;">No stock holdings</td></tr>';
      
      // This week section
      const thisWeek = earningsList.filter(e => e.daysAway !== null && e.daysAway >= 0 && e.daysAway <= 7);
      if (thisWeek.length > 0) {
        thisWeekDiv.innerHTML = thisWeek.map(e => `
          <div class="watchlist-item" style="border-left: 3px solid #f85149;">
            <div>
              <div class="watchlist-ticker">${e.symbol} - ${e.name}</div>
              <div class="watchlist-note">${formatDate(e.date)} (${e.daysAway === 0 ? 'TODAY' : e.daysAway + ' days away'})</div>
            </div>
            <span class="negative" style="font-weight: 600;">‚ö†Ô∏è Earnings</span>
          </div>
        `).join('');
      } else {
        thisWeekDiv.innerHTML = '<p style="color:#8b949e;">No earnings this week for your holdings.</p>';
      }
    }
    
    async function fetchEarningsDates() {
      const btn = document.getElementById('refreshEarningsBtn');
      btn.disabled = true;
      btn.innerHTML = '‚è≥ Fetching...';
      
      const stockHoldings = data.holdings.filter(h => h.type === 'stock');
      const symbols = stockHoldings.map(h => h.symbol);
      
      try {
        const res = await fetch('/api/earnings', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ symbols })
        });
        
        if (res.ok) {
          const result = await res.json();
          if (result.earnings) {
            Object.assign(earningsData, result.earnings);
            console.log('‚úÖ Earnings data fetched:', Object.keys(result.earnings).length, 'symbols');
          }
        }
      } catch (e) {
        console.error('‚ùå Error fetching earnings:', e);
      }
      
      localStorage.setItem('earnings-data', JSON.stringify(earningsData));
      renderEarnings();
      
      btn.disabled = false;
      btn.innerHTML = 'üîÑ Refresh Dates';
    }
    
    // ==================== WATCHLIST ANALYSIS ====================
    let storedWatchlistAnalysis = JSON.parse(localStorage.getItem('pinky-watchlist-analysis') || 'null');
    
    function renderWatchlistAnalysis() {
      const card = document.getElementById('watchlistAnalysisCard');
      const text = document.getElementById('watchlistAnalysisText');
      const timestamp = document.getElementById('watchlistAnalysisTimestamp');
      const noMsg = document.getElementById('noWatchlistAnalysisMsg');
      
      if (storedWatchlistAnalysis && storedWatchlistAnalysis.text) {
        card.style.display = 'block';
        noMsg.style.display = 'none';
        text.innerHTML = formatAnalysisText(storedWatchlistAnalysis.text);
        timestamp.textContent = formatDate(storedWatchlistAnalysis.timestamp);
      } else {
        card.style.display = 'none';
        noMsg.style.display = 'block';
      }
    }
    
    async function analyzeWatchlist() {
      const btn = document.getElementById('watchlistAnalysisBtn');
      const card = document.getElementById('watchlistAnalysisCard');
      const text = document.getElementById('watchlistAnalysisText');
      const timestamp = document.getElementById('watchlistAnalysisTimestamp');
      const noMsg = document.getElementById('noWatchlistAnalysisMsg');
      
      if (data.watchlist.length === 0) {
        alert('Add some stocks to your watchlist first!');
        return;
      }
      
      btn.disabled = true;
      btn.innerHTML = '‚è≥ Analyzing...';
      card.style.display = 'block';
      noMsg.style.display = 'none';
      text.textContent = 'Analyzing watchlist against your current portfolio...';
      timestamp.textContent = 'Loading...';
      
      try {
        const { stocksValue, cryptoValue, totalValue } = calculateTotals();
        
        const response = await fetch('/api/recommend', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            holdings: data.holdings,
            watchlist: data.watchlist,
            totalValue,
            stocksValue,
            cryptoValue,
            type: 'watchlist'
          })
        });
        
        const result = await response.json();
        
        if (result.error) {
          text.textContent = `‚ùå Error: ${result.error}`;
        } else {
          storedWatchlistAnalysis = { text: result.analysis, timestamp: result.timestamp || new Date().toISOString() };
          localStorage.setItem('pinky-watchlist-analysis', JSON.stringify(storedWatchlistAnalysis));
          renderWatchlistAnalysis();
        }
        
      } catch (error) {
        console.error('Watchlist analysis error:', error);
        text.textContent = `‚ùå Error: ${error.message}. Try again later.`;
      }
      
      btn.disabled = false;
      btn.innerHTML = 'üîç Analyze Watchlist';
    }
    
    function editEarningsDate(symbol) {
      const currentDate = earningsData[symbol]?.date || '';
      const newDate = prompt(`Enter earnings date for ${symbol} (YYYY-MM-DD):`, currentDate);
      
      if (newDate && /^\d{4}-\d{2}-\d{2}$/.test(newDate)) {
        earningsData[symbol] = { date: newDate, time: 'TBD' };
        localStorage.setItem('earnings-data', JSON.stringify(earningsData));
        renderEarnings();
        console.log(`‚úÖ Updated ${symbol} earnings date to ${newDate}`);
      } else if (newDate !== null) {
        alert('Invalid date format. Use YYYY-MM-DD (e.g., 2026-02-15)');
      }
    }
    
    // ==================== INIT ====================
    // Check session AFTER all code is defined (at the very end)
    if (sessionStorage.getItem(SESSION_KEY) === 'true') {
      console.log('Session found, showing app...');
      showApp();
    } else {
      console.log('No session, showing login screen');
    }
  </script>
</body>
</html>
<!-- deployed Mon Feb  2 22:08:30 CET 2026 -->
<!-- auto-deploy trigger 1770068072 -->
<!-- fix: 1770068774 -->
<!-- rebuild 1770069243 -->
